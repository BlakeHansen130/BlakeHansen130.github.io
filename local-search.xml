<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vim</title>
    <link href="/2024/10/20/vim/"/>
    <url>/2024/10/20/vim/</url>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>Vim 是一个 <em>多模态</em> 编辑 器：它对于插入文字和操纵文字有不同的模式。Vim 是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim 的接口本身也是一个程序语言：键入操作（以及其助记名） 是命令，这些命令也是可组合的。<br>normal模式下按i进入insert模式；按r进入replace模式；按v进入visual模式；按<S-V>ji进入visual-line模式；按^V进入visual-block模式，，再按esc返回normal。<br>按：进入command-line模式，输入q<enter>退出当前选项卡，qa<enter>退出所有。</p><h2 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h2><p>control+v的三种表示方法：^V Ctrl-V <C-V></p><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>命令行模式下，:help 后输入想查询的内容可看到功能，注意要问带冒号的命令则也要带冒号，例如:help :w。<code>:w</code>表示保存更改。</p><h3 id="打开文件和缓存"><a href="#打开文件和缓存" class="headerlink" title="打开文件和缓存"></a>打开文件和缓存</h3><ul><li><code>:e &#123;文件名&#125;</code> 打开要编辑的文件</li><li><code>:ls</code> 显示打开的缓存</li></ul><h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><ul><li><strong>分割窗口</strong>：<ul><li><code>:split</code> 或 <code>Ctrl-w s</code>: 水平分割窗口</li><li><code>:vsplit</code> 或 <code>Ctrl-w v</code>: 垂直分割窗口</li></ul></li><li><strong>关闭窗口</strong>：<ul><li><code>:q</code> 或 <code>:close</code>: 关闭当前窗口</li><li><code>:qa</code> 或 <code>:qall</code>: 关闭所有窗口</li></ul></li><li><strong>移动光标到其他窗口</strong>：<ul><li><code>Ctrl-w w</code>: 在窗口之间循环切换</li><li><code>Ctrl-w h/j/k/l</code>: 移动光标到左&#x2F;下&#x2F;上&#x2F;右的窗口</li></ul></li></ul><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><ul><li><strong>查看缓冲区列表</strong>：<ul><li><code>:buffers</code> 或 <code>:ls</code></li></ul></li><li><strong>切换缓冲区</strong>：<ul><li><code>:bn</code> 或 <code>:bp</code>: 切换到下一个&#x2F;上一个缓冲区</li><li><code>:b &#123;number&#125;</code>: 切换到指定编号的缓冲区</li></ul></li><li><strong>删除缓冲区</strong>：<ul><li><code>:bd &#123;number&#125;</code>: 删除指定编号的缓冲区</li></ul></li></ul><h3 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h3><ul><li><strong>创建新选项卡</strong>：<ul><li><code>:tabnew</code> 或 <code>gt</code></li></ul></li><li><strong>关闭选项卡</strong>：<ul><li><code>:tabclose</code> 或 <code>:tabc</code></li></ul></li><li><strong>切换选项卡</strong>：<ul><li><code>gt</code>: 切换到下一个选项卡</li><li><code>gT</code>: 切换到上一个选项卡</li><li><code>:tabn &#123;number&#125;</code>: 切换到指定编号的选项卡</li></ul></li></ul><h2 id="normal模式下的移动"><a href="#normal模式下的移动" class="headerlink" title="normal模式下的移动"></a>normal模式下的移动</h2><ul><li><strong>h:</strong> 向左移动一个字符</li><li><strong>j:</strong> 向下移动一行。在命令前加上数字，表示重复执行该命令的次数。例如，<code>5j</code> 表示向下移动5行。</li><li><strong>k:</strong> 向上移动一行</li><li><strong>l:</strong> 向右移动一个字符</li><li><strong>w:</strong> 移动到下一个单词的开头</li><li><strong>b:</strong> 移动到上一个单词的开头</li><li><strong>e:</strong> 移动到下一个单词的末尾</li><li><strong>^:</strong> 移动到行首</li><li><strong>$:</strong> 移动到行尾</li><li><strong>gg:</strong> 移动到文件开头</li><li><strong>G:</strong> 移动到文件末尾</li><li><strong>Ctrl+u:</strong> 向上滚动半屏</li><li><strong>Ctrl+d:</strong> 向下滚动半屏</li><li><strong>Ctrl+f:</strong> 向下滚动一屏</li><li><strong>Ctrl+b:</strong> 向上滚动一屏</li><li><strong>跳转：</strong> 使用<code>f</code>或<code>t</code>可以跳转到当前行中下一个或上一个出现的指定字符。例如，<code>fx</code> 表示跳转到下一个出现的字母x。</li><li>行数： <code>:&#123;行数&#125;&lt;CR&gt;</code> 或者 <code>&#123;行数&#125;G</code> ({行数}为行数)</li><li>杂项： <code>%</code> （找到配对，比如括号或者 &#x2F;* *&#x2F; 之类的注释对）</li></ul><h3 id="f命令"><a href="#f命令" class="headerlink" title="f命令"></a>f命令</h3><ul><li><strong>功能：</strong> 将光标移动到当前行中下一个出现的指定字符处。</li><li><strong>用法：</strong> <code>fx</code>，其中x表示你要跳转到的字符。例如，<code>fw</code>表示跳转到下一个单词的开头。</li></ul><h3 id="t命令"><a href="#t命令" class="headerlink" title="t命令"></a>t命令</h3><ul><li><strong>功能：</strong> 将光标移动到当前行中下一个出现的指定字符<strong>之前</strong>。</li><li><strong>用法：</strong> <code>tx</code>，其中x表示你要跳转到的字符。例如，<code>tw</code>表示跳转到下一个单词的开头<strong>之前</strong>。</li></ul><h3 id="扩展用法"><a href="#扩展用法" class="headerlink" title="扩展用法"></a>扩展用法</h3><ul><li><strong>重复跳转：</strong> 使用分号<code>;</code>可以重复上一次的f或t命令。例如，如果你输入<code>fa</code>，然后输入<code>;</code>，光标会继续跳转到下一个出现的”a”。</li><li><strong>反向跳转：</strong> 使用逗号<code>,</code>可以反向重复上一次的f或t命令。例如，如果你输入<code>fa</code>，然后输入<code>,</code>，光标会跳转到上一个出现的”a”。</li><li><strong>结合数字：</strong> 在f或t命令前加上数字，可以指定跳转的次数。例如，<code>2fw</code>表示跳转到下一个单词的开头，然后再跳转到下一个单词的开头。</li><li><strong>大写F和T：</strong> F和T命令与f和t类似，但它们是向左搜索。例如，<code>Fx</code>会向左搜索第一个出现的x。</li><li>屏幕： <code>H</code> （屏幕首行）， <code>M</code> （屏幕中间）， <code>L</code> （屏幕底部）</li></ul><h2 id="insert模式"><a href="#insert模式" class="headerlink" title="insert模式"></a>insert模式</h2><p><strong>Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。</strong></p><h3 id="o命令"><a href="#o命令" class="headerlink" title="o命令"></a>o命令</h3><ul><li><strong>功能：</strong> 在当前行的<strong>下方</strong>插入一个新行，并进入插入模式。</li><li><strong>用法：</strong> 在正常模式下，将光标移动到想要插入新行的位置，然后输入<code>o</code>。</li></ul><h3 id="O命令"><a href="#O命令" class="headerlink" title="O命令"></a>O命令</h3><ul><li><strong>功能：</strong> 在当前行的<strong>上方</strong>插入一个新行，并进入插入模式。</li><li><strong>用法：</strong> 在正常模式下，将光标移动到想要插入新行的位置，然后输入<code>O</code>。</li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><strong>删除字符：</strong><ul><li><code>x</code>：删除光标下的字符</li><li><code>X</code>：删除光标前的字符</li></ul></li><li><strong>删除整行：</strong><ul><li><code>dd</code>：删除当前行</li></ul></li><li><strong>删除到行尾：</strong><ul><li><code>d$</code>：删除从光标处到行尾的所有字符</li></ul></li><li><strong>删除到行首：</strong><ul><li><code>d0</code>：删除从光标处到行首的所有字符</li></ul></li><li><code>s</code> 替换字符（等同于 <code>xi</code>）</li></ul><h3 id="与移动命令结合"><a href="#与移动命令结合" class="headerlink" title="与移动命令结合"></a>与移动命令结合</h3><ul><li><code>dw</code>：删除到下一个单词的开头</li><li><code>de</code>：删除到下一个单词的结尾</li><li><code>db</code>：删除到上一个单词的开头</li><li><code>dd</code>：删除当前行</li><li><code>2dd</code>：删除当前行和下一行</li><li><code>daw</code>：删除光标所在单词</li></ul><h3 id="撤销操作："><a href="#撤销操作：" class="headerlink" title="撤销操作："></a>撤销操作：</h3><ul><li><strong>u：</strong> 撤销上一步操作。连续按多次u可以撤销多个步骤。并且如果从insert模式返回到normal模式以后按u，会撤销在insert模式的所有操作。</li></ul><h3 id="重做操作："><a href="#重做操作：" class="headerlink" title="重做操作："></a>重做操作：</h3><ul><li><strong>Ctrl+r：</strong> 重做上一步撤销的操作。</li></ul><h3 id="其他撤销相关命令："><a href="#其他撤销相关命令：" class="headerlink" title="其他撤销相关命令："></a>其他撤销相关命令：</h3><ul><li><strong>U：</strong> 撤销对当前行的所有修改。</li><li><strong>:undo</strong>：显示撤销列表，并允许你选择要撤销到哪个状态。</li></ul><h3 id="c命令：修改文本"><a href="#c命令：修改文本" class="headerlink" title="c命令：修改文本"></a>c命令：修改文本</h3><ul><li><strong>cw</strong>: 修改光标后的一个单词</li><li><strong>ce</strong>: 修改光标后的一个单词，直到单词末尾</li><li><strong>cb</strong>: 修改光标前的一个单词</li><li><strong>cc</strong>: 修改整行</li><li><strong>c$</strong>: 修改从光标到行尾的所有字符</li><li><strong>c0</strong>: 修改从光标到行首的所有字符<br>c和d唯一的区别就是在删除内容以后将你设置为insert状态</li></ul><h3 id="结合数字"><a href="#结合数字" class="headerlink" title="结合数字"></a>结合数字</h3><ul><li><strong>c2w</strong>: 修改接下来的两个单词</li><li><strong>c3l</strong>: 修改接下来的三个字符</li><li><strong>c.$</strong>: 修改到句号。</li><li><strong>c)</strong>: 修改到下一个”)”。</li><li><strong>c{</strong>: 修改到下一个”{“。</li></ul><h3 id="r命令"><a href="#r命令" class="headerlink" title="r命令"></a>r命令</h3><p><strong>rx</strong>: 将光标下的字符替换为x。例如，<code>ra</code> 将把光标下的字符替换为”a”。</p><ul><li><strong>字符选取：</strong><ul><li><code>v</code>：进入可视模式，然后使用光标键选择字符。</li></ul></li><li><strong>单词选取：</strong><ul><li><code>vw</code>：选中光标所在单词。</li><li><code>ve</code>：选中光标所在单词到单词末尾。</li><li><code>vb</code>：选中光标所在单词到单词开始。</li></ul></li><li><strong>行选取：</strong><ul><li><code>V</code>：进入行可视模式，选中整行。甚至可以按方块形状进行选择。</li><li><code>ggVG</code>：选中整个文件。</li></ul></li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>选中文本后，使用<code>y</code>命令进行复制。例如：</p><ul><li><code>vwyy</code>：选中当前单词并复制。</li><li><code>Vyy</code>：选中当前行并复制。</li></ul><h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p>复制后的文本可以使用<code>p</code>命令进行粘贴。</p><ul><li><code>p</code>：在光标下方粘贴。</li><li><code>P</code>：在光标上方粘贴。</li></ul><h3 id="大小写命令"><a href="#大小写命令" class="headerlink" title="大小写命令"></a>大小写命令</h3><h3 id="单个字符"><a href="#单个字符" class="headerlink" title="#单个字符"></a>#单个字符</h3><ul><li><strong><code>~</code> 命令：</strong> 将光标下的字符大小写反转。</li></ul><h4 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h4><ul><li><strong><code>g~iw</code>：</strong> 将光标下的单词大小写反转。<ul><li>例子：将单词”hello”转换为”HELLO”。</li></ul></li></ul><h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><ul><li><strong><code>guu</code>：</strong> 将当前行所有字母转换为小写。</li><li><strong><code>gUU</code>：</strong> 将当前行所有字母转换为大写。</li><li><strong><code>gu0</code>：</strong> 将光标所在位置到行首的字母转换为小写。</li><li><strong><code>gU0</code>：</strong> 将光标所在位置到行首的字母转换为大写。</li><li><strong><code>gu$</code>：</strong> 将光标所在位置到行尾的字母转换为小写。</li><li><strong><code>gU$</code>：</strong> 将光标所在位置到行尾的字母转换为大写。</li></ul><h4 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h4><ul><li><strong><code>gu</code> 或 <code>gU</code>：</strong> 在可视模式下，选中部分文本后，使用<code>gu</code>将其转换为小写，使用<code>gU</code>将其转换为大写。</li></ul><h2 id="修饰语"><a href="#修饰语" class="headerlink" title="修饰语"></a>修饰语</h2><p>修饰语有 <code>i</code>，表示“内部”或者“在内”，和 <code>a</code>， 表示“周围”。</p><ul><li><code>ci(</code> 改变当前括号内的内容</li><li><code>ci[</code> 改变当前方括号内的内容</li><li><code>da&#39;</code> 删除一个单引号字符串， 包括周围的单引号</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Shell Tools and Scripting</title>
    <link href="/2024/10/20/Shell%20Tools%20and%20Scripting/"/>
    <url>/2024/10/20/Shell%20Tools%20and%20Scripting/</url>
    
    <content type="html"><![CDATA[<h1 id="Shell-Tools-and-Scripting"><a href="#Shell-Tools-and-Scripting" class="headerlink" title="Shell Tools and Scripting"></a>Shell Tools and Scripting</h1><h2 id="变量-函数"><a href="#变量-函数" class="headerlink" title="变量 函数"></a>变量 函数</h2><p>在shell中要注意空格的使用，尤其是在进行与名字字符串中带有空格的文件有关的操作时。<br><code>&quot;$ variable name&quot;</code>可以使用变量。<br><code>source function</code>可以在shell中执行函数，然后<code>function folder/file</code>就可以检验了。<br><code>$0</code>是脚本名称，<code>$?</code>获取上一个命令的错误代码，<code>$_</code>获取上一个命令参数，例如文件或文件夹等，<code>$#</code>给出的参数数量，<code>$$</code>获取pid(process id)，<code>$@</code>扩展到所有参数。<br>常见的退出状态码示例：</p><ul><li><strong>1：</strong> 一般表示命令执行时出现了错误。</li><li><strong>2：</strong> 可能表示命令使用不正确，例如参数错误。</li><li><strong>127：</strong> 表示命令未找到。</li><li><strong>126：</strong> 表示命令找到，但无法执行（例如没有执行权限）。<br><img src="/img/20241006222138.png"><br><code>!!</code>表示获取上一段命令，例如上一段命令执行结果是没有管理员权限，那么可以<code>sudo !!</code>来解决。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><code>||</code>或，<code>&amp;&amp;</code>与，<code>;</code>分隔多个命令，顺序执行。<br><code>$(command)</code>也可以代表相应的输出内容，<code>cat &lt;(command)</code>也可以实现输出内容。</p><h3 id="dev-null"><a href="#dev-null" class="headerlink" title="&#x2F;dev&#x2F;null"></a>&#x2F;dev&#x2F;null</h3><p>在类Unix系统中是一个特殊的设备文件，常被称为“空设备”或“比特桶”。你可以把它想象成一个无底洞，任何写入到它的数据都会被丢弃，而从它读取数据永远只会得到一个空的回应。<br>&#x2F;dev&#x2F;null 的作用</p><ul><li><strong>丢弃输出：</strong> 当你执行一个命令，但不想看到它的输出结果时，可以将输出重定向到 &#x2F;dev&#x2F;null。这在自动化脚本或批量处理任务中非常常见。</li><li><strong>抑制错误信息：</strong> 某些命令执行时可能会产生错误信息。如果这些错误信息对你来说无关紧要，可以将错误信息重定向到 &#x2F;dev&#x2F;null。</li><li><strong>创建空文件：</strong> 可以通过将特定内容写入 &#x2F;dev&#x2F;null 来创建一个空文件。<br>例如：<code>find / -name &quot;*.tmp&quot; -delete &gt; /dev/null 2&gt;&amp;1</code>这条命令会查找系统中所有以 <code>.tmp</code> 结尾的文件并删除，同时将命令的标准输出和标准错误输出都重定向到 &#x2F;dev&#x2F;null，避免在终端显示任何信息。<code>2&gt;&amp;1</code>这是一个在 Shell 脚本中经常用到的重定向符号，用于 <strong>将标准错误输出重定向到标准输出</strong>。**<code>2&gt;&amp;1</code> 的意思就是：** 把标准错误输出（2）重定向到标准输出（1）。也就是说，原本应该显示在终端上的错误信息，现在也会和正常的输出信息一起显示。</li><li><strong>标准输出（stdout）：</strong> 通常是显示在终端上的输出信息，用数字 1 表示。</li><li><strong>标准错误输出（stderr）：</strong> 通常是显示在终端上的错误信息，用数字 2 表示。</li></ul><h2 id="查看、修改文件"><a href="#查看、修改文件" class="headerlink" title="查看、修改文件"></a>查看、修改文件</h2><p><code>*.sh</code>是大多数sehll文件扩展名。<br><code>ls filename?</code>可以查看相应问号位数名字的文件。<br><code>convert filename.&#123;png.jpg&#125;</code>可以把图片格式从png转化成jpg，也可以加名字序号。<br><code>touch &#123;folder1,folder2&#125;/&#123;file1..filen&#125;</code>可以遍历这两个文件夹中的所有名字中含有某个字符的文件。<br><strong>touch</strong> 命令是一个常用的 Linux&#x2F;Unix 命令，主要用于 <strong>修改文件的时间戳</strong> 或 <strong>创建新文件</strong>。<br><strong>mv -i</strong> 命令在移动或重命名文件时会 <strong>先询问用户</strong>，以避免误操作导致数据丢失。<br>convert可用于转换图片，ffmep可用于处理视频。</p><h2 id="shebang"><a href="#shebang" class="headerlink" title="shebang"></a>shebang</h2><p><strong>&#x2F;usr&#x2F;bin&#x2F;env</strong>： 这部分告诉系统使用 <code>env</code> 命令来查找指定的可执行程序。<code>env</code> 命令会搜索当前用户的环境变量 <code>PATH</code>，找到第一个匹配的程序。<br>例如：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-meta">#!/usr/bin/env python3</span><br>print(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br></code></pre></td></tr></table></figure><p>用系统环境中的 Python3 解释器来执行这个脚本。</p><h2 id="调试-查找"><a href="#调试-查找" class="headerlink" title="调试 查找"></a>调试 查找</h2><p><code>shellcheck *.sh</code>检查警告和语法错误等。<br><strong><code>tldr command</code></strong> 查询命令用法，是一个为命令行工具提供简明易懂的使用说明的工具。它从冗长的 <code>man</code> 手册中提取出最常用的用法和示例，让用户能快速上手各种命令。<br><code>find</code>或<code>fd</code>用于查找文件名字，<code>locate</code>用于查找并列出所有，<code>grep</code>用于查找文件或文件夹中的具体内容，<code>rg</code>是ripgrep的缩写，是比grep更快的文本搜索工具，<code>fzf</code>模糊查找。<br>例如：<code>rg -U --files-without-match &quot;^#\!&quot; -t sh</code>表示<strong>在当前目录及其子目录中，查找所有的 shell 脚本文件（.sh），并找出那些</strong>第一行不是以 <code>#</code> 和 <code>!</code> 开头的的文件。其中<code>^</code>: 表示行首。<code>#</code>: 匹配字符#。<code>\!</code>: 匹配字符 !。<br><code>Ctrl+R</code>可以查找历史中出现要查找的字符的代码，每按一次就出现一条。<br><code>zsh</code>可以提供历史推荐代码。<br><code>tree</code>和<code>broot</code>都是很好的文件搜索和管理工具。</p><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><p>1、要求我们使用 <code>ls</code> 命令，并通过添加不同的参数来实现以下功能：</p><ul><li><strong>显示所有文件（包括隐藏文件）</strong></li><li><strong>以人类可读的格式显示文件大小</strong></li><li><strong>按照文件访问时间排序</strong></li><li><strong>使用彩色输出</strong><br>答：ls -lah –color&#x3D;auto<br>-l 以长格式显示；-a 显示所有文件，包括隐藏文件；-h 以人类可读的格式显示文件大小。</li></ul><p>2、编写两个 bash 函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便 debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code> 命令，（重新）加载函数。<br>答：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># marco.sh</span><br><span class="hljs-comment"># marco 函数：保存当前目录路径</span><br><span class="hljs-function"><span class="hljs-title">marco</span></span>() &#123;<br><span class="hljs-built_in">export</span> SAVED_DIR=<span class="hljs-string">&quot;<span class="hljs-subst">$(pwd)</span>&quot;</span> <span class="hljs-comment"># 使用 export 将变量导出，使得它可以被其他 shell 访问</span><br>&#125;<br><span class="hljs-comment"># polo 函数：跳转回保存的目录</span><br><span class="hljs-function"><span class="hljs-title">polo</span></span>() &#123;<br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$SAVED_DIR</span>&quot;</span> ]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 检查 SAVED_DIR 是否为空，其中-z STRING：如果字符串STRING的长度为零（即为空字符串），则返回真（true），否则返回假（false）。</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error: No directory saved. Please run &#x27;marco&#x27; first.&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$SAVED_DIR</span>&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error: Could not change to directory <span class="hljs-variable">$SAVED_DIR</span>&quot;</span><br><span class="hljs-keyword">fi</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3、假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段 bash 脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。<br>答：修改后的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env bash</span><br><br>  <br><br><span class="hljs-comment"># 初始化计数器</span><br><br>count=0<br><br>log_file=<span class="hljs-string">&quot;command_log.txt&quot;</span> <span class="hljs-comment"># 定义一个变量 log_file ，用来存储日志文件路径</span><br><br>  <br><br><span class="hljs-comment"># 清空或创建日志文件</span><br><br>&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span> <span class="hljs-comment"># 将日志文件清空，如果文件不存在则创建。</span><br><br>  <br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span><br><br><span class="hljs-comment"># 运行给定的命令，同时捕获标准输出和标准错误</span><br><br>n=$((RANDOM % <span class="hljs-number">100</span>)) <span class="hljs-comment"># 生成一个 0 到 99 之间的随机数，并赋值给变量 n。</span><br><br><span class="hljs-keyword">if</span> [[ n -eq 42 ]]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 判断 n 是否等于 42，如果等于，则执行 then 后面的语句。</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Something went wrong&quot;</span> <span class="hljs-comment"># 标准输出。在bash中如果不指定输出重定向，则echo默认标准输出，因此不需要显式指定&gt;&amp;1。</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The error was using magic numbers&quot;</span> &gt;&amp;2 <span class="hljs-comment"># 标准错误输出</span><br><br><span class="hljs-comment"># 记录错误信息到日志文件</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;执行失败，总共执行了 <span class="hljs-variable">$count</span> 次&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;最后一次执行的输出：&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;标准输出：Something went wrong&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;标准错误：The error was using magic numbers&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span><br><br><span class="hljs-comment"># 显示日志文件内容</span><br><br><span class="hljs-built_in">cat</span> <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span><br><br><span class="hljs-built_in">exit</span> 1 <span class="hljs-comment"># 退出脚本，并返回一个非零的退出状态，表示程序执行失败。从这里可以跳出while和do的循环。</span><br><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Everything went according to plan&quot;</span><br><br>((count++))<br><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>对于标准输出和标准错误输出，有如下例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"># 将正确的信息输出到 <span class="hljs-built_in">output</span>.txt，错误信息输出到 <span class="hljs-built_in">error</span>.<span class="hljs-built_in">log</span><br>command &gt; <span class="hljs-built_in">output</span>.txt <span class="hljs-number">2</span>&gt; <span class="hljs-built_in">error</span>.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>4、您的任务是编写一个命令，它可以递归地查找文件夹中所有的 HTML 文件，并将它们压缩成 zip 文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行。<br>答：<code>find . -type f -name &quot;*.html&quot; -print0 | xargs -0 zip html_files.zip **使用 </code>-print0<code>和</code>xargs -0&#96;：**</p><ul><li><code>-print0</code> 会让 <code>find</code> 输出的文件名之间用<strong>null 字符</strong> (<code>\0</code>) 进行分隔，而不是空格或换行符。</li><li><code>xargs -0</code> 会识别这些 null 字符，并将整个文件名（包括空格在内）作为一个单独的参数传递。</li></ul><p>5、编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？<br>答：&#96;find &#x2F;path -type f -printf “%T+ %p\n” | sort -r<br>其中</p><ul><li><strong><code>-printf &quot;%T+ %p\n&quot;</code>：</strong> 以 “+%Y-%m-%d %H:%M:%S” 格式输出文件的访问时间和路径。</li><li><strong><code>sort -r</code>：</strong> 按时间戳逆序排序，最近访问的文件排在前面。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Deep Learning by 3Blue1Brown</title>
    <link href="/2024/10/15/3Blue1Brown/"/>
    <url>/2024/10/15/3Blue1Brown/</url>
    
    <content type="html"><![CDATA[<h1 id="Deep-Learning-by-3Blue1Brown"><a href="#Deep-Learning-by-3Blue1Brown" class="headerlink" title="Deep Learning by 3Blue1Brown"></a>Deep Learning by 3Blue1Brown</h1><h3 id="MLP的结构"><a href="#MLP的结构" class="headerlink" title="MLP的结构"></a>MLP的结构</h3><ul><li><strong>输入层：</strong> 接收原始数据，每个神经元对应一个输入特征。</li><li><strong>隐藏层：</strong> 位于输入层和输出层之间，包含多个神经元。隐藏层的神经元通过非线性激活函数对输入数据进行变换，从而提取出数据的特征。</li><li><strong>输出层：</strong> 输出网络的预测结果，神经元的个数取决于任务类型（分类、回归等）。<br><strong>MLP（Multi-Layer Perceptron）</strong>，即<strong>多层感知机</strong>，是深度学习中最基础的神经网络模型之一。它可以看作是感知机的扩展，通过引入多个隐藏层，使得网络能够学习到更加复杂的非线性映射关系。</li></ul><h3 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h3><p>也称为<strong>S型函数</strong>或<strong>逻辑斯蒂函数</strong>，是一种在生物学、信息科学、神经网络等多个领域广泛应用的数学函数。<br>表达式：<code>f(x) = 1 / (1 + e^(-x))</code></p><ul><li><strong>取值范围：</strong> 函数的值域为(0, 1)，这使得它可以将任意实数映射到0到1之间的概率值，常用于表示神经元的激活程度。</li><li><strong>连续性：</strong> Sigmoid函数是连续可导的，这使得它可以用于梯度下降等优化算法。</li><li><strong>非线性：</strong> Sigmoid函数是非线性的，这使得神经网络能够拟合复杂的非线性关系。<br>Sigmoid函数在神经网络中的作用</li><li><strong>作为激活函数：</strong> Sigmoid函数是早期神经网络中常用的激活函数。它可以将线性输入转化为非线性输出，从而使神经网络具有学习复杂模式的能力。</li><li><strong>将输出限制在0-1之间：</strong> 在二分类问题中，Sigmoid函数可以将输出解释为属于正类的概率。<br><strong>机器学习即是要找到正确的权重的偏置，使代价函数最小化。<br>神经网络本身就是一个大型函数。</strong><br><img src="/img/20241014220021.png"></li></ul><h3 id="反向传播算法（Backpropagation，BP）"><a href="#反向传播算法（Backpropagation，BP）" class="headerlink" title="反向传播算法（Backpropagation，BP）"></a>反向传播算法（Backpropagation，BP）</h3><p>工作原理：</p><ol><li><strong>前向传播：</strong> 输入数据从输入层开始，经过隐藏层，最后到达输出层。每一层的神经元计算加权和，并通过激活函数得到输出。</li><li><strong>计算损失：</strong> 将网络的输出与实际的标签进行比较，计算出损失函数的值。常见的损失函数有均方误差、交叉熵损失等。</li><li><strong>反向传播：</strong> 从输出层开始，计算损失函数对输出层每个神经元的偏导数。然后利用链式法则，逐层向前计算损失函数对隐藏层和输入层神经元的偏导数。</li><li><strong>更新参数：</strong> 根据计算得到的梯度，利用梯度下降法更新网络中的权重和偏置。<br>四个计算方程：</li></ol><ul><li><p><strong>误差项 δ 的定义：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">δ<span class="hljs-symbol">^L</span> = ∂C/∂z<span class="hljs-symbol">^L</span><br></code></pre></td></tr></table></figure><p>  其中：</p><ul><li>δ^L：第 L 层第 j 个神经元的误差项。</li><li>C：损失函数。</li><li>z^L：第 L 层第 j 个神经元的输入。</li></ul></li><li><p><strong>误差项 δ 的计算：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">δ<span class="hljs-symbol">^l</span> = (<span class="hljs-keyword">w</span>^(<span class="hljs-keyword">l</span>+<span class="hljs-number">1</span>))<span class="hljs-symbol">^T</span> δ^(<span class="hljs-keyword">l</span>+<span class="hljs-number">1</span>) * σ&#x27;(z<span class="hljs-symbol">^l</span>)<br></code></pre></td></tr></table></figure><p>  其中：</p><ul><li>w^(l+1)：第 l 层到第 l+1 层之间的权重矩阵。</li><li>σ’(z^l)：第 l 层第 j 个神经元的激活函数的导数。</li></ul></li><li><p><strong>偏置的梯度：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">∂C/∂b<span class="hljs-symbol">^l_j</span> = δ<span class="hljs-symbol">^l_j</span><br></code></pre></td></tr></table></figure></li><li><p><strong>权重的梯度：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">∂C/∂<span class="hljs-keyword">w</span><span class="hljs-symbol">^l_jk</span> = a^(<span class="hljs-keyword">l</span>-<span class="hljs-number">1</span>)_k δ<span class="hljs-symbol">^l_j</span><br></code></pre></td></tr></table></figure><p>  其中：</p><ul><li>a^(l-1)_k：第 l-1 层第 k 个神经元的输出。</li></ul></li></ul><h3 id="随机梯度下降（Stochastic-Gradient-Descent，SGD）"><a href="#随机梯度下降（Stochastic-Gradient-Descent，SGD）" class="headerlink" title="随机梯度下降（Stochastic Gradient Descent，SGD）"></a>随机梯度下降（Stochastic Gradient Descent，SGD）</h3><p>SGD 的主要特点在于每次迭代只随机选取一个样本（或一小批样本）来计算梯度，并根据这个梯度来更新参数。</p><h3 id="gpt"><a href="#gpt" class="headerlink" title="gpt"></a>gpt</h3><p>GPT，全称Generative Pre-trained Transformer，中文翻译为生成式预训练变换器。<br><strong>Transformer架构:</strong> GPT模型的核心是Transformer架构。Transformer是一种神经网络架构，特别适合处理序列数据，如文本。它利用自注意力机制，让模型能够关注输入序列的不同部分，从而更好地理解文本的上下文。<br>word embedding过后方向可以代表语义。</p><h3 id="softmax函数"><a href="#softmax函数" class="headerlink" title="softmax函数"></a>softmax函数</h3><p>它的作用是将一个任意实数的K维向量“压缩”到另一个K维实向量中，使得每一个元素的范围都在(0,1)之间，并且所有元素的和为1。换句话说，它将输入的数值转化为一个概率分布。其输入称为logits，输出称为probabilities。<br>Softmax函数引入温度参数后的形式：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">y_i = <span class="hljs-built_in">exp</span>(z_i / <span class="hljs-built_in">T</span>) / Σ(<span class="hljs-built_in">exp</span>(z_j / <span class="hljs-built_in">T</span>))<br></code></pre></td></tr></table></figure><ul><li><code>y_i</code>: 输出向量y的第i个元素，表示输入数据属于第i类的概率。</li><li><code>z_i</code>: 输入向量z的第i个元素。</li><li><code>T</code>: 温度参数。<br><strong>高温度 (T较大):</strong> 概率分布会变得更加平滑，各类别之间的概率差异减小，模型会倾向于给所有类别分配较高的概率。这在一些场景下可以增加模型的探索性，例如在生成模型中生成多样化的样本。 <strong>低温度 (T较小):</strong> 概率分布会变得更加尖锐，模型会更加自信地将概率分配给最有可能的类别。这在需要模型做出明确决策的场景下非常有用，例如分类任务。</li></ul><h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><p>它允许模型在处理大量输入数据时，有选择性地关注其中最相关的部分，从而提升模型的性能。<br><strong>数学表达:</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Attention</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Query</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Key</span><span class="hljs-operator">,</span> <span class="hljs-variable">Value</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-variable">softmax</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Query</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">Key</span><span class="hljs-operator">^</span><span class="hljs-variable">T</span> <span class="hljs-operator">/</span> <span class="hljs-variable">sqrt</span><span class="hljs-punctuation">(</span><span class="hljs-type">d_k</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">*</span> <span class="hljs-variable">Value</span><br></code></pre></td></tr></table></figure><ul><li><strong>Query:</strong> 表示当前需要关注的元素。</li><li><strong>Key:</strong> 表示所有输入元素的键。</li><li><strong>Value:</strong> 表示所有输入元素的值。</li><li><strong>softmax:</strong> 将相似度转化为概率分布。</li><li><strong>d_k:</strong> 是Key向量的维度。</li></ul><h3 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h3><p>通常，掩码是一个与输入序列长度相同的向量，每个元素的值为0或1。值为0的位置会被屏蔽，即在计算注意力权重时，这些位置的权重会被设置为一个非常小的负数（例如-inf），从而使得softmax函数将这些位置的概率归为0。<br>掩码的应用场景</p><ul><li><strong>机器翻译:</strong> 防止模型在翻译过程中“偷看”目标序列。</li><li><strong>文本生成:</strong> 确保生成的文本是连贯的，符合语法规则。</li><li><strong>问答系统:</strong> 控制模型只关注与问题相关的部分。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>fyp</title>
    <link href="/2024/10/07/fyp/"/>
    <url>/2024/10/07/fyp/</url>
    
    <content type="html"><![CDATA[<p><strong>使用的mcu：</strong><br>esp32<br><strong>历史设备：</strong><br>Kinect for Windows<br><a href="https://learn.microsoft.com/en-us/windows/apps/design/devices/kinect-for-windows">https://learn.microsoft.com/en-us/windows/apps/design/devices/kinect-for-windows</a><br>Nintendo Wii<br><a href="https://www.nintendo.com/en-gb/Wii/Wii-94559.html?srsltid=AfmBOor8Xo1tet1IBXyGMjGHbShVLkBfER8bSEsyGtisKmdRG3AfMNrp">https://www.nintendo.com/en-gb/Wii/Wii-94559.html?srsltid=AfmBOor8Xo1tet1IBXyGMjGHbShVLkBfER8bSEsyGtisKmdRG3AfMNrp</a><br><strong>相关仓库：</strong></p><ul><li><strong>MediaPipe Solutions（重点参考应用案例）:</strong> Google 开发的跨平台框架，包含多种机器学习解决方案，其中手势识别解决方案非常强大，提供了实时、高精度的手势跟踪和分类功能。<ul><li><strong>链接:</strong> <a href="https://github.com/google/mediapipe">https://github.com/google/mediapipe</a></li></ul></li><li><strong>OpenPose:</strong> 一个实时多人二维姿态估计库，可以用于手势识别。它可以准确地检测人体关键点，为手势识别提供基础数据。<ul><li><strong>链接:</strong> <a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose">https://github.com/CMU-Perceptual-Computing-Lab/openpose</a></li></ul></li><li><strong>TensorFlow Examples:</strong> TensorFlow 官方提供的示例代码，包含多个手势识别相关的示例，如使用 TensorFlow 和 Keras 实现手势分类。<ul><li><strong>链接:</strong> <a href="https://github.com/tensorflow/examples">https://github.com/tensorflow/examples</a></li></ul></li><li><strong>RealGes:</strong> 一个基于视觉的实时动态手势识别系统，包含数据采集、模型训练、实时预测等完整流程。<ul><li><strong>链接:</strong> <a href="https://github.com/wzh99/RealGes">https://github.com/wzh99/RealGes</a><br><strong>编程和平台：</strong><br>arduino（功能较弱）<br><strong>Arduino IDE：</strong> Arduino IDE 是一个开源的集成开发环境，通过安装 ESP32 的核心库，可以方便地进行开发。<br>vscode上可以装插件用C++编程。<br><strong>学习：</strong><br>不要看forest和svm，要从cnn、rnn、gan等开始看起。从类似项目中找使用cnn、rnn的方法，从中入手学习。每个人都要交单独的report。中期报告的时候要有设计方案和初步产品。汇报进度时准备PPT。<br><strong>理想流程：</strong><br>先做图像处理，再把数据放进learing model中处理，观察得到的结果。<br><strong>老师推荐的学习链接：</strong><br><a href="https://docs.espressif.com/projects/esp-dl/zh_CN/latest/esp32/index.html">https://docs.espressif.com/projects/esp-dl/zh_CN/latest/esp32/index.html</a><br><a href="https://developer.espressif.com/blog/hand-gesture-recognition-on-esp32-s3-with-esp-deep-learning/">https://developer.espressif.com/blog/hand-gesture-recognition-on-esp32-s3-with-esp-deep-learning/</a><br><a href="https://github.com/margaretmz/awesome-tensorflow-lite">https://github.com/margaretmz/awesome-tensorflow-lite</a><br><a href="https://github.com/espressif/esp-tflite-micro">https://github.com/espressif/esp-tflite-micro</a></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>The Shell</title>
    <link href="/2024/10/04/The%20Shell/"/>
    <url>/2024/10/04/The%20Shell/</url>
    
    <content type="html"><![CDATA[<p>刚启动shell terminal的时候出现的是shell prompt<br>shell是一门编程语言，依靠invariable environment</p><h2 id="date-echo-which"><a href="#date-echo-which" class="headerlink" title="date echo which"></a>date echo which</h2><p><code>date</code>显示日期<br><code>echo &quot;string&quot;</code>回复字符串内容<br><code>echo $PATH</code>查看路径<br><code>which echo</code>查看echo程序位置</p><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>linux和macOS中用&#x2F;(forward slash)分隔path，windows中用(back slash)分隔path<br><code>pwd</code>print working directory<br><code>cd</code>change directory<br><code>.</code>current directory <code>..</code>parent directory <code>~</code>表示用户目录，例如在linux中表示&#x2F;home&#x2F;dahao，在windows中表示C:\Users\dahao <code>-</code>表示上一个目录</p><h2 id="ls-man"><a href="#ls-man" class="headerlink" title="ls man"></a>ls man</h2><p><code>ls</code>留空表示显示当前目录，后面也可以加例如..来显示其父目录<br><code>ls --help</code>help <code>ls -l</code>long list help<br><img src="/img/20241004144604.png"><br>每三个字母为一组，第一组为user owner的权限，第二组为group owner的权限，第三组为everyone else，每行的第一个字母表示文件的类型或文件夹</p><ul><li><strong>d:</strong> 代表这是一个目录 (directory)。</li><li><strong>-:</strong> 代表这是一个普通文件 (regular file)。</li><li><strong>l:</strong> 代表这是一个符号链接 (symbolic link)。</li><li><strong>b:</strong> 代表这是一个块设备文件 (block special file)。</li><li><strong>c:</strong> 代表这是一个字符设备文件 (character special file)。</li><li><strong>p:</strong> 代表这是一个管道文件 (FIFO pipe)。</li><li><strong>s:</strong> 代表这是一个套接字文件 (socket)。<br>其中write的权限，对于文件夹来说表示可以在其中rename\create\remove files。例如对文件夹中的某个文件具有write权限，但对文件夹没有write权限，那么只能把文件内容清空而不能把这个文件从文件夹中删掉。<br>execute权限表示想访问一个文件（夹）就需要对它和它父目录有execute权限。<br><code>man ls</code>manual page，可能需要q退出<br><code>Ctrl+L</code>clean terminal<br>在macOS中，<code>xdg-open file</code>用对应软件打开文件</li></ul><h2 id="mv-cp-rm"><a href="#mv-cp-rm" class="headerlink" title="mv cp rm"></a>mv cp rm</h2><p><code>mv</code>move and rename<br><code>cp</code>copy and rename<br><code>rm</code>remove，linux中不能rm文件夹，因为不是递归删除，需要删除加<code>-r</code><br><code>rmdir</code>only if the directory is empty<br><code>mkdir</code>创建新文件夹</p><h2 id="input-output"><a href="#input-output" class="headerlink" title="input output"></a>input output</h2><p><code>&lt;</code>input <code>&gt;</code>output <code>&gt;&gt;</code>append<br><code>cat &lt; file</code>表示把file的内容当做input内容，默认output到terminal<br><code>cat &lt; file &gt; file2</code>表示output到file2中<br><code>tail -n+number</code>例如<code>tail -n2</code>表示print最后2行<br><code>A | B</code>把A代码段的输出作为B代码段的输入，A和B彼此不知<br><strong>重定向的优先级更高</strong></p><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>linux和macOS的root用户id是0，是super user(su)，类似于windows的administrator<br><code>ls /sys</code>kernel parameters<br><code>$</code>表示你不是在以root方式运行 <code>#</code>相反<br><code>sudo su</code>获得root权限 <code>exit</code>退出<br>例如<code>echo 1060 | sudo tee brightness</code>表示先把1060作为输入内容，再获得管理员权限并同时输出到brightness文件和terminal screen</p><h3 id="为什么sudo-echo-500-brightness不行而echo-500-sudo-tee-brightness可以"><a href="#为什么sudo-echo-500-brightness不行而echo-500-sudo-tee-brightness可以" class="headerlink" title="为什么sudo echo 500 &gt; brightness不行而echo 500 | sudo tee brightness可以"></a>为什么<code>sudo echo 500 &gt; brightness</code>不行而<code>echo 500 | sudo tee brightness</code>可以</h3><p>原因：<br><code>sudo echo 500 &gt; brightness</code> 为什么不行？</p><ul><li><strong>重定向优先级高于 sudo：</strong> 在这个命令中，Shell首先会执行重定向操作 <code>&gt; brightness</code>，试图将 <code>echo 500</code> 的输出重定向到 <code>brightness</code> 文件。</li><li><strong>权限不足：</strong> 在执行重定向时，Shell发现你没有写入 <code>brightness</code> 文件的权限，因此报错“不允许”。</li><li><strong>sudo 权限范围：</strong> 即使你使用了 <code>sudo</code>，它也只是提升了 <code>echo</code> 命令的权限，并没有提升 Shell 执行重定向操作的权限。<br><code>echo 500 | sudo tee brightness</code> 为什么可以？</li><li><strong>管道操作：</strong> <code>|</code> 符号表示管道，将 <code>echo 500</code> 的输出作为 <code>sudo tee brightness</code> 的输入。</li><li><strong>sudo tee 权限：</strong> <code>sudo tee brightness</code> 这部分命令由 <code>sudo</code> 提升了权限，因此可以将数据写入 <code>brightness</code> 文件。</li><li><strong>tee 命令的作用：</strong> <code>tee</code> 命令可以同时将标准输入的内容输出到标准输出和指定的文件。<br>总结：</li><li><strong>重定向操作发生在 sudo 之前：</strong> 在 <code>sudo echo 500 &gt; brightness</code> 中，重定向操作先于 <code>sudo</code> 执行，导致权限不足。</li><li><strong>管道操作将输出交给 sudo 处理：</strong> 在 <code>echo 500 | sudo tee brightness</code> 中，重定向操作通过管道交给 <code>sudo tee</code> 处理，从而绕过了权限问题。</li></ul><h2 id="exercise"><a href="#exercise" class="headerlink" title="exercise"></a>exercise</h2><p>使用<code>echo $SHELL</code>命令可以查看您的shell是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则证明可以使用类Unix shell的。<br>如何使用shell，将以下内容一行一行地写入 semester 文件：<br> <code>#!/bin/sh  curl --head --silent https://missing.csail.mit.edu</code><br> 答案：<code>echo &#39;#!/bin/sh&#39; &gt; semester</code><br><code>echo &#39;curl --head --silent https://missing.csail.mit.edu&#39; &gt;&gt; semester</code><br>为什么使用单引号而不是双引号？</p><ul><li>单引号： 单引号内的所有字符都会被原样输出，包括特殊字符（如$、&#96;、\等）。也就是说，单引号内的内容不会被shell解释。</li><li>双引号： 双引号内的部分特殊字符会被shell解释，比如变量会被替换，命令替换也会执行。<br>为什么 # 和 ! 不需要转义？</li><li>#号： 在shell脚本中，#号通常表示注释。当shell遇到#号时，会忽略该行#号后面的所有内容。但是，当#号被包含在单引号或双引号中时，它就失去了注释的作用，而被视为普通字符。</li><li>!号：!号在shell中也有多种用途，但在这里，它只是字符串的一部分，不需要转义。</li><li>如果要在单引号中包含单引号本身，需要使用转义字符&#39;。</li><li>如果需要在单引号中嵌入变量，可以先将变量的值赋值给另一个变量，然后使用双引号包裹这个变量。</li></ul><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>可以通过修改 chmod 命令中的字母来赋予文件不同的权限。</p><h3 id="权限字母详解"><a href="#权限字母详解" class="headerlink" title="权限字母详解"></a>权限字母详解</h3><ul><li>u: 表示文件所有者 (user)</li><li>g: 表示与文件所有者同组的用户 (group)</li><li>o: 表示其他用户 (others)</li><li>a: 表示所有用户 (all users，即 u、g、o 的总和)</li><li>+: 增加权限</li><li>-: 删除权限</li><li>&#x3D;: 设定权限（仅设置指定的权限，其他权限取消）</li><li>r: 读权限</li><li>w: 写权限</li><li>x: 执行权限<br>举例<br>chmod g-w semester: 取消同组用户的写权限<br>chmod o&#x3D;r semester: 仅给其他用户赋予读权限，其他权限取消<br>chmod a+x semester: 给所有用户增加执行权限</li></ul><h3 id="数字表示法"><a href="#数字表示法" class="headerlink" title="数字表示法"></a>数字表示法</h3><p>除了使用字母表示，还可以使用数字表示权限，每个数字代表一组权限：</p><ul><li>rwx: 7</li><li>rw-: 6</li><li>r-x: 5</li><li>r–: 4</li><li>-wx: 3</li><li>-w-: 2</li><li>–x: 1</li><li>—: 0<br>例如：<br>chmod 755 semester: 表示文件所有者有读、写、执行权限，同组用户和其他人有读和执行权限。<br><strong>Shebang 行（#!）的作用：</strong><br>解释器指定: Shebang 行（#!）位于脚本的第一行，其后紧跟着解释器的路径。这行告诉系统，用指定的解释器来执行这个脚本。<br>示例: #!&#x2F;bin&#x2F;sh 表示使用 &#x2F;bin&#x2F;sh 这个 shell 来解释执行脚本。<br>作用: 当系统执行一个脚本时，会首先读取 Shebang 行，然后找到指定的解释器，并把脚本的内容传递给解释器执行。<br><strong>获取修改时间：</strong></li><li>方法一：<code>stat -c %y semester | cut -d &#39; &#39; -f 1 &gt; ./last-modified.txt</code><br>stat -c %y semester：获取semester文件的修改时间，并以年-月-日的格式输出。<br>cut -d ‘ ‘ -f 1：从输出结果中提取第一个字段（即日期），也就是修改时间。<blockquote><p>~&#x2F;last-modified.txt：将提取到的修改时间重定向到当前用户主目录下的last-modified.txt文件中。</p></blockquote></li><li>方法二：<code>ls -l semester | awk &#39;&#123;print $6&quot; &quot;$7&#125;&#39; | cut -d &#39; &#39; -f 1 &gt; ./last-modified.txt</code><br>ls -l semester：以长格式列出semester文件的信息，包括修改时间。<br>awk ‘{print $6” “$7}’：提取输出中的第6和第7个字段，即月日和时间。<br>cut -d ‘ ‘ -f 1：从提取到的结果中提取第一个字段（即日期），也就是修改时间。<blockquote><p>~&#x2F;last-modified.txt：将提取到的修改时间重定向到当前用户主目录下的last-modified.txt文件中。</p></blockquote></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/02/hello-world/"/>
    <url>/2024/10/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
