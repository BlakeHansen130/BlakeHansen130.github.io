<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Deep Learning by 3Blue1Brown</title>
    <link href="/2024/10/15/3Blue1Brown/"/>
    <url>/2024/10/15/3Blue1Brown/</url>
    
    <content type="html"><![CDATA[<h1 id="Deep-Learning-by-3Blue1Brown"><a href="#Deep-Learning-by-3Blue1Brown" class="headerlink" title="Deep Learning by 3Blue1Brown"></a>Deep Learning by 3Blue1Brown</h1><h3 id="MLP的结构"><a href="#MLP的结构" class="headerlink" title="MLP的结构"></a>MLP的结构</h3><ul><li><strong>输入层：</strong> 接收原始数据，每个神经元对应一个输入特征。</li><li><strong>隐藏层：</strong> 位于输入层和输出层之间，包含多个神经元。隐藏层的神经元通过非线性激活函数对输入数据进行变换，从而提取出数据的特征。</li><li><strong>输出层：</strong> 输出网络的预测结果，神经元的个数取决于任务类型（分类、回归等）。<br><strong>MLP（Multi-Layer Perceptron）</strong>，即<strong>多层感知机</strong>，是深度学习中最基础的神经网络模型之一。它可以看作是感知机的扩展，通过引入多个隐藏层，使得网络能够学习到更加复杂的非线性映射关系。</li></ul><h3 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h3><p>也称为<strong>S型函数</strong>或<strong>逻辑斯蒂函数</strong>，是一种在生物学、信息科学、神经网络等多个领域广泛应用的数学函数。<br>表达式：<code>f(x) = 1 / (1 + e^(-x))</code></p><ul><li><strong>取值范围：</strong> 函数的值域为(0, 1)，这使得它可以将任意实数映射到0到1之间的概率值，常用于表示神经元的激活程度。</li><li><strong>连续性：</strong> Sigmoid函数是连续可导的，这使得它可以用于梯度下降等优化算法。</li><li><strong>非线性：</strong> Sigmoid函数是非线性的，这使得神经网络能够拟合复杂的非线性关系。<br>Sigmoid函数在神经网络中的作用</li><li><strong>作为激活函数：</strong> Sigmoid函数是早期神经网络中常用的激活函数。它可以将线性输入转化为非线性输出，从而使神经网络具有学习复杂模式的能力。</li><li><strong>将输出限制在0-1之间：</strong> 在二分类问题中，Sigmoid函数可以将输出解释为属于正类的概率。<br><strong>机器学习即是要找到正确的权重的偏置，使代价函数最小化。<br>神经网络本身就是一个大型函数。</strong><br><img src="/img/20241014220021.png"></li></ul><h3 id="反向传播算法（Backpropagation，BP）"><a href="#反向传播算法（Backpropagation，BP）" class="headerlink" title="反向传播算法（Backpropagation，BP）"></a>反向传播算法（Backpropagation，BP）</h3><p>工作原理：</p><ol><li><strong>前向传播：</strong> 输入数据从输入层开始，经过隐藏层，最后到达输出层。每一层的神经元计算加权和，并通过激活函数得到输出。</li><li><strong>计算损失：</strong> 将网络的输出与实际的标签进行比较，计算出损失函数的值。常见的损失函数有均方误差、交叉熵损失等。</li><li><strong>反向传播：</strong> 从输出层开始，计算损失函数对输出层每个神经元的偏导数。然后利用链式法则，逐层向前计算损失函数对隐藏层和输入层神经元的偏导数。</li><li><strong>更新参数：</strong> 根据计算得到的梯度，利用梯度下降法更新网络中的权重和偏置。<br>四个计算方程：</li></ol><ul><li><p><strong>误差项 δ 的定义：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">δ<span class="hljs-symbol">^L</span> = ∂C/∂z<span class="hljs-symbol">^L</span><br></code></pre></td></tr></table></figure><p>  其中：</p><ul><li>δ^L：第 L 层第 j 个神经元的误差项。</li><li>C：损失函数。</li><li>z^L：第 L 层第 j 个神经元的输入。</li></ul></li><li><p><strong>误差项 δ 的计算：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">δ<span class="hljs-symbol">^l</span> = (<span class="hljs-keyword">w</span>^(<span class="hljs-keyword">l</span>+<span class="hljs-number">1</span>))<span class="hljs-symbol">^T</span> δ^(<span class="hljs-keyword">l</span>+<span class="hljs-number">1</span>) * σ&#x27;(z<span class="hljs-symbol">^l</span>)<br></code></pre></td></tr></table></figure><p>  其中：</p><ul><li>w^(l+1)：第 l 层到第 l+1 层之间的权重矩阵。</li><li>σ’(z^l)：第 l 层第 j 个神经元的激活函数的导数。</li></ul></li><li><p><strong>偏置的梯度：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">∂C/∂b<span class="hljs-symbol">^l_j</span> = δ<span class="hljs-symbol">^l_j</span><br></code></pre></td></tr></table></figure></li><li><p><strong>权重的梯度：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">∂C/∂<span class="hljs-keyword">w</span><span class="hljs-symbol">^l_jk</span> = a^(<span class="hljs-keyword">l</span>-<span class="hljs-number">1</span>)_k δ<span class="hljs-symbol">^l_j</span><br></code></pre></td></tr></table></figure><p>  其中：</p><ul><li>a^(l-1)_k：第 l-1 层第 k 个神经元的输出。</li></ul></li></ul><h3 id="随机梯度下降（Stochastic-Gradient-Descent，SGD）"><a href="#随机梯度下降（Stochastic-Gradient-Descent，SGD）" class="headerlink" title="随机梯度下降（Stochastic Gradient Descent，SGD）"></a>随机梯度下降（Stochastic Gradient Descent，SGD）</h3><p>SGD 的主要特点在于每次迭代只随机选取一个样本（或一小批样本）来计算梯度，并根据这个梯度来更新参数。</p><h3 id="gpt"><a href="#gpt" class="headerlink" title="gpt"></a>gpt</h3><p>GPT，全称Generative Pre-trained Transformer，中文翻译为生成式预训练变换器。<br><strong>Transformer架构:</strong> GPT模型的核心是Transformer架构。Transformer是一种神经网络架构，特别适合处理序列数据，如文本。它利用自注意力机制，让模型能够关注输入序列的不同部分，从而更好地理解文本的上下文。<br>word embedding过后方向可以代表语义。</p><h3 id="softmax函数"><a href="#softmax函数" class="headerlink" title="softmax函数"></a>softmax函数</h3><p>它的作用是将一个任意实数的K维向量“压缩”到另一个K维实向量中，使得每一个元素的范围都在(0,1)之间，并且所有元素的和为1。换句话说，它将输入的数值转化为一个概率分布。其输入称为logits，输出称为probabilities。<br>Softmax函数引入温度参数后的形式：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">y_i = <span class="hljs-built_in">exp</span>(z_i / <span class="hljs-built_in">T</span>) / Σ(<span class="hljs-built_in">exp</span>(z_j / <span class="hljs-built_in">T</span>))<br></code></pre></td></tr></table></figure><ul><li><code>y_i</code>: 输出向量y的第i个元素，表示输入数据属于第i类的概率。</li><li><code>z_i</code>: 输入向量z的第i个元素。</li><li><code>T</code>: 温度参数。<br><strong>高温度 (T较大):</strong> 概率分布会变得更加平滑，各类别之间的概率差异减小，模型会倾向于给所有类别分配较高的概率。这在一些场景下可以增加模型的探索性，例如在生成模型中生成多样化的样本。 <strong>低温度 (T较小):</strong> 概率分布会变得更加尖锐，模型会更加自信地将概率分配给最有可能的类别。这在需要模型做出明确决策的场景下非常有用，例如分类任务。</li></ul><h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><p>它允许模型在处理大量输入数据时，有选择性地关注其中最相关的部分，从而提升模型的性能。<br><strong>数学表达:</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Attention</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Query</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Key</span><span class="hljs-operator">,</span> <span class="hljs-variable">Value</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-variable">softmax</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Query</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">Key</span><span class="hljs-operator">^</span><span class="hljs-variable">T</span> <span class="hljs-operator">/</span> <span class="hljs-variable">sqrt</span><span class="hljs-punctuation">(</span><span class="hljs-type">d_k</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">*</span> <span class="hljs-variable">Value</span><br></code></pre></td></tr></table></figure><ul><li><strong>Query:</strong> 表示当前需要关注的元素。</li><li><strong>Key:</strong> 表示所有输入元素的键。</li><li><strong>Value:</strong> 表示所有输入元素的值。</li><li><strong>softmax:</strong> 将相似度转化为概率分布。</li><li><strong>d_k:</strong> 是Key向量的维度。</li></ul><h3 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h3><p>通常，掩码是一个与输入序列长度相同的向量，每个元素的值为0或1。值为0的位置会被屏蔽，即在计算注意力权重时，这些位置的权重会被设置为一个非常小的负数（例如-inf），从而使得softmax函数将这些位置的概率归为0。<br>掩码的应用场景</p><ul><li><strong>机器翻译:</strong> 防止模型在翻译过程中“偷看”目标序列。</li><li><strong>文本生成:</strong> 确保生成的文本是连贯的，符合语法规则。</li><li><strong>问答系统:</strong> 控制模型只关注与问题相关的部分。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>fyp</title>
    <link href="/2024/10/07/fyp/"/>
    <url>/2024/10/07/fyp/</url>
    
    <content type="html"><![CDATA[<p><strong>使用的mcu：</strong><br>esp32<br><strong>历史设备：</strong><br>Kinect for Windows<br><a href="https://learn.microsoft.com/en-us/windows/apps/design/devices/kinect-for-windows">https://learn.microsoft.com/en-us/windows/apps/design/devices/kinect-for-windows</a><br>Nintendo Wii<br><a href="https://www.nintendo.com/en-gb/Wii/Wii-94559.html?srsltid=AfmBOor8Xo1tet1IBXyGMjGHbShVLkBfER8bSEsyGtisKmdRG3AfMNrp">https://www.nintendo.com/en-gb/Wii/Wii-94559.html?srsltid=AfmBOor8Xo1tet1IBXyGMjGHbShVLkBfER8bSEsyGtisKmdRG3AfMNrp</a><br><strong>相关仓库：</strong></p><ul><li><strong>MediaPipe Solutions（重点参考应用案例）:</strong> Google 开发的跨平台框架，包含多种机器学习解决方案，其中手势识别解决方案非常强大，提供了实时、高精度的手势跟踪和分类功能。<ul><li><strong>链接:</strong> <a href="https://github.com/google/mediapipe">https://github.com/google/mediapipe</a></li></ul></li><li><strong>OpenPose:</strong> 一个实时多人二维姿态估计库，可以用于手势识别。它可以准确地检测人体关键点，为手势识别提供基础数据。<ul><li><strong>链接:</strong> <a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose">https://github.com/CMU-Perceptual-Computing-Lab/openpose</a></li></ul></li><li><strong>TensorFlow Examples:</strong> TensorFlow 官方提供的示例代码，包含多个手势识别相关的示例，如使用 TensorFlow 和 Keras 实现手势分类。<ul><li><strong>链接:</strong> <a href="https://github.com/tensorflow/examples">https://github.com/tensorflow/examples</a></li></ul></li><li><strong>RealGes:</strong> 一个基于视觉的实时动态手势识别系统，包含数据采集、模型训练、实时预测等完整流程。<ul><li><strong>链接:</strong> <a href="https://github.com/wzh99/RealGes">https://github.com/wzh99/RealGes</a><br><strong>编程和平台：</strong><br>arduino（功能较弱）<br><strong>Arduino IDE：</strong> Arduino IDE 是一个开源的集成开发环境，通过安装 ESP32 的核心库，可以方便地进行开发。<br>vscode上可以装插件用C++编程。<br><strong>学习：</strong><br>不要看forest和svm，要从cnn、rnn、gan等开始看起。从类似项目中找使用cnn、rnn的方法，从中入手学习。每个人都要交单独的report。中期报告的时候要有设计方案和初步产品。汇报进度时准备PPT。<br><strong>理想流程：</strong><br>先做图像处理，再把数据放进learing model中处理，观察得到的结果。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>The Shell</title>
    <link href="/2024/10/04/The%20Shell/"/>
    <url>/2024/10/04/The%20Shell/</url>
    
    <content type="html"><![CDATA[<p>刚启动shell terminal的时候出现的是shell prompt<br>shell是一门编程语言，依靠invariable environment</p><h2 id="date-echo-which"><a href="#date-echo-which" class="headerlink" title="date echo which"></a>date echo which</h2><p><code>date</code>显示日期<br><code>echo &quot;string&quot;</code>回复字符串内容<br><code>echo $PATH</code>查看路径<br><code>which echo</code>查看echo程序位置</p><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>linux和macOS中用&#x2F;(forward slash)分隔path，windows中用(back slash)分隔path<br><code>pwd</code>print working directory<br><code>cd</code>change directory<br><code>.</code>current directory <code>..</code>parent directory <code>~</code>表示用户目录，例如在linux中表示&#x2F;home&#x2F;dahao，在windows中表示C:\Users\dahao <code>-</code>表示上一个目录</p><h2 id="ls-man"><a href="#ls-man" class="headerlink" title="ls man"></a>ls man</h2><p><code>ls</code>留空表示显示当前目录，后面也可以加例如..来显示其父目录<br><code>ls --help</code>help <code>ls -l</code>long list help<br><img src="/img/20241004144604.png"><br>每三个字母为一组，第一组为user owner的权限，第二组为group owner的权限，第三组为everyone else，每行的第一个字母表示文件的类型或文件夹</p><ul><li><strong>d:</strong> 代表这是一个目录 (directory)。</li><li><strong>-:</strong> 代表这是一个普通文件 (regular file)。</li><li><strong>l:</strong> 代表这是一个符号链接 (symbolic link)。</li><li><strong>b:</strong> 代表这是一个块设备文件 (block special file)。</li><li><strong>c:</strong> 代表这是一个字符设备文件 (character special file)。</li><li><strong>p:</strong> 代表这是一个管道文件 (FIFO pipe)。</li><li><strong>s:</strong> 代表这是一个套接字文件 (socket)。<br>其中write的权限，对于文件夹来说表示可以在其中rename\create\remove files。例如对文件夹中的某个文件具有write权限，但对文件夹没有write权限，那么只能把文件内容清空而不能把这个文件从文件夹中删掉。<br>execute权限表示想访问一个文件（夹）就需要对它和它父目录有execute权限。<br><code>man ls</code>manual page，可能需要q退出<br><code>Ctrl+L</code>clean terminal<br>在macOS中，<code>xdg-open file</code>用对应软件打开文件</li></ul><h2 id="mv-cp-rm"><a href="#mv-cp-rm" class="headerlink" title="mv cp rm"></a>mv cp rm</h2><p><code>mv</code>move and rename<br><code>cp</code>copy and rename<br><code>rm</code>remove，linux中不能rm文件夹，因为不是递归删除，需要删除加<code>-r</code><br><code>rmdir</code>only if the directory is empty<br><code>mkdir</code>创建新文件夹</p><h2 id="input-output"><a href="#input-output" class="headerlink" title="input output"></a>input output</h2><p><code>&lt;</code>input <code>&gt;</code>output <code>&gt;&gt;</code>append<br><code>cat &lt; file</code>表示把file的内容当做input内容，默认output到terminal<br><code>cat &lt; file &gt; file2</code>表示output到file2中<br><code>tail -n+number</code>例如<code>tail -n2</code>表示print最后2行<br><code>A | B</code>把A代码段的输出作为B代码段的输入，A和B彼此不知<br><strong>重定向的优先级更高</strong></p><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>linux和macOS的root用户id是0，是super user(su)，类似于windows的administrator<br><code>ls /sys</code>kernel parameters<br><code>$</code>表示你不是在以root方式运行 <code>#</code>相反<br><code>sudo su</code>获得root权限 <code>exit</code>退出<br>例如<code>echo 1060 | sudo tee brightness</code>表示先把1060作为输入内容，再获得管理员权限并同时输出到brightness文件和terminal screen</p><h3 id="为什么sudo-echo-500-brightness不行而echo-500-sudo-tee-brightness可以"><a href="#为什么sudo-echo-500-brightness不行而echo-500-sudo-tee-brightness可以" class="headerlink" title="为什么sudo echo 500 &gt; brightness不行而echo 500 | sudo tee brightness可以"></a>为什么<code>sudo echo 500 &gt; brightness</code>不行而<code>echo 500 | sudo tee brightness</code>可以</h3><p>原因：<br><code>sudo echo 500 &gt; brightness</code> 为什么不行？</p><ul><li><strong>重定向优先级高于 sudo：</strong> 在这个命令中，Shell首先会执行重定向操作 <code>&gt; brightness</code>，试图将 <code>echo 500</code> 的输出重定向到 <code>brightness</code> 文件。</li><li><strong>权限不足：</strong> 在执行重定向时，Shell发现你没有写入 <code>brightness</code> 文件的权限，因此报错“不允许”。</li><li><strong>sudo 权限范围：</strong> 即使你使用了 <code>sudo</code>，它也只是提升了 <code>echo</code> 命令的权限，并没有提升 Shell 执行重定向操作的权限。<br><code>echo 500 | sudo tee brightness</code> 为什么可以？</li><li><strong>管道操作：</strong> <code>|</code> 符号表示管道，将 <code>echo 500</code> 的输出作为 <code>sudo tee brightness</code> 的输入。</li><li><strong>sudo tee 权限：</strong> <code>sudo tee brightness</code> 这部分命令由 <code>sudo</code> 提升了权限，因此可以将数据写入 <code>brightness</code> 文件。</li><li><strong>tee 命令的作用：</strong> <code>tee</code> 命令可以同时将标准输入的内容输出到标准输出和指定的文件。<br>总结：</li><li><strong>重定向操作发生在 sudo 之前：</strong> 在 <code>sudo echo 500 &gt; brightness</code> 中，重定向操作先于 <code>sudo</code> 执行，导致权限不足。</li><li><strong>管道操作将输出交给 sudo 处理：</strong> 在 <code>echo 500 | sudo tee brightness</code> 中，重定向操作通过管道交给 <code>sudo tee</code> 处理，从而绕过了权限问题。</li></ul><h2 id="exercise"><a href="#exercise" class="headerlink" title="exercise"></a>exercise</h2><p>使用<code>echo $SHELL</code>命令可以查看您的shell是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则证明可以使用类Unix shell的。<br>如何使用shell，将以下内容一行一行地写入 semester 文件：<br> <code>#!/bin/sh  curl --head --silent https://missing.csail.mit.edu</code><br> 答案：<code>echo &#39;#!/bin/sh&#39; &gt; semester</code><br><code>echo &#39;curl --head --silent https://missing.csail.mit.edu&#39; &gt;&gt; semester</code><br>为什么使用单引号而不是双引号？</p><ul><li>单引号： 单引号内的所有字符都会被原样输出，包括特殊字符（如$、&#96;、\等）。也就是说，单引号内的内容不会被shell解释。</li><li>双引号： 双引号内的部分特殊字符会被shell解释，比如变量会被替换，命令替换也会执行。<br>为什么 # 和 ! 不需要转义？</li><li>#号： 在shell脚本中，#号通常表示注释。当shell遇到#号时，会忽略该行#号后面的所有内容。但是，当#号被包含在单引号或双引号中时，它就失去了注释的作用，而被视为普通字符。</li><li>!号：!号在shell中也有多种用途，但在这里，它只是字符串的一部分，不需要转义。</li><li>如果要在单引号中包含单引号本身，需要使用转义字符&#39;。</li><li>如果需要在单引号中嵌入变量，可以先将变量的值赋值给另一个变量，然后使用双引号包裹这个变量。</li></ul><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>可以通过修改 chmod 命令中的字母来赋予文件不同的权限。</p><h3 id="权限字母详解"><a href="#权限字母详解" class="headerlink" title="权限字母详解"></a>权限字母详解</h3><ul><li>u: 表示文件所有者 (user)</li><li>g: 表示与文件所有者同组的用户 (group)</li><li>o: 表示其他用户 (others)</li><li>a: 表示所有用户 (all users，即 u、g、o 的总和)</li><li>+: 增加权限</li><li>-: 删除权限</li><li>&#x3D;: 设定权限（仅设置指定的权限，其他权限取消）</li><li>r: 读权限</li><li>w: 写权限</li><li>x: 执行权限<br>举例<br>chmod g-w semester: 取消同组用户的写权限<br>chmod o&#x3D;r semester: 仅给其他用户赋予读权限，其他权限取消<br>chmod a+x semester: 给所有用户增加执行权限</li></ul><h3 id="数字表示法"><a href="#数字表示法" class="headerlink" title="数字表示法"></a>数字表示法</h3><p>除了使用字母表示，还可以使用数字表示权限，每个数字代表一组权限：</p><ul><li>rwx: 7</li><li>rw-: 6</li><li>r-x: 5</li><li>r–: 4</li><li>-wx: 3</li><li>-w-: 2</li><li>–x: 1</li><li>—: 0<br>例如：<br>chmod 755 semester: 表示文件所有者有读、写、执行权限，同组用户和其他人有读和执行权限。<br><strong>Shebang 行（#!）的作用：</strong><br>解释器指定: Shebang 行（#!）位于脚本的第一行，其后紧跟着解释器的路径。这行告诉系统，用指定的解释器来执行这个脚本。<br>示例: #!&#x2F;bin&#x2F;sh 表示使用 &#x2F;bin&#x2F;sh 这个 shell 来解释执行脚本。<br>作用: 当系统执行一个脚本时，会首先读取 Shebang 行，然后找到指定的解释器，并把脚本的内容传递给解释器执行。<br><strong>获取修改时间：</strong></li><li>方法一：<code>stat -c %y semester | cut -d &#39; &#39; -f 1 &gt; ./last-modified.txt</code><br>stat -c %y semester：获取semester文件的修改时间，并以年-月-日的格式输出。<br>cut -d ‘ ‘ -f 1：从输出结果中提取第一个字段（即日期），也就是修改时间。<blockquote><p>~&#x2F;last-modified.txt：将提取到的修改时间重定向到当前用户主目录下的last-modified.txt文件中。</p></blockquote></li><li>方法二：<code>ls -l semester | awk &#39;&#123;print $6&quot; &quot;$7&#125;&#39; | cut -d &#39; &#39; -f 1 &gt; ./last-modified.txt</code><br>ls -l semester：以长格式列出semester文件的信息，包括修改时间。<br>awk ‘{print $6” “$7}’：提取输出中的第6和第7个字段，即月日和时间。<br>cut -d ‘ ‘ -f 1：从提取到的结果中提取第一个字段（即日期），也就是修改时间。<blockquote><p>~&#x2F;last-modified.txt：将提取到的修改时间重定向到当前用户主目录下的last-modified.txt文件中。</p></blockquote></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/02/hello-world/"/>
    <url>/2024/10/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
