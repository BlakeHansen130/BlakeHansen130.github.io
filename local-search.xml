<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>building_with_espdl-3-failure</title>
    <link href="/2024/11/07/building_with_espdl-3-failure/"/>
    <url>/2024/11/07/building_with_espdl-3-failure/</url>
    
    <content type="html"><![CDATA[<h1 id="building-with-espdl-3-failure"><a href="#building-with-espdl-3-failure" class="headerlink" title="building_with_espdl-3-failure"></a>building_with_espdl-3-failure</h1><p>这部分在实践的过程中知识有点杂，因此笔记稍显混乱。</p><h2 id="windows中的powershell"><a href="#windows中的powershell" class="headerlink" title="windows中的powershell"></a>windows中的powershell</h2><h3 id="类似ls的shell语言"><a href="#类似ls的shell语言" class="headerlink" title="类似ls的shell语言"></a>类似ls的shell语言</h3><h4 id="Get-ChildItem"><a href="#Get-ChildItem" class="headerlink" title="Get-ChildItem"></a>Get-ChildItem</h4><p>列出当前目录下的所有文件和文件夹：<code>Get-ChildItem</code><br>递归列出指定目录下的所有文件和文件夹：<code>Get-ChildItem -Recurse C:\MyDocuments</code><br>筛选特定类型的文件：<code>Get-ChildItem -Filter *.txt</code><br><strong>常用参数：</strong></p><ul><li><code>-Path</code>: 指定要获取子项的路径。</li><li><code>-Recurse</code>: 递归搜索子目录。</li><li><code>-Filter</code>: 根据文件名模式筛选文件。</li><li><code>-Include</code>: 指定要包含的文件名模式。</li><li><code>-Exclude</code>: 指定要排除的文件名模式。</li><li><code>-Directory</code>: 只返回目录。</li><li><code>-File</code>: 只返回文件。</li></ul><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>列出当前目录下的所有文件和文件夹：<code>dir</code><br>以简略格式列出：<code>dir /B</code><br>只列出目录：<code>dir /AD</code><br><strong>常用参数：</strong></p><ul><li><code>/B</code>: 以简略格式列出。</li><li><code>/AD</code>: 只列出目录。</li><li><code>/S</code>: 递归搜索子目录。</li></ul><h3 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h3><p>打开jupyter notebook中ipynb文件自动关闭jupyter终端：<br><a href="https://blog.csdn.net/qq_45404853/article/details/121310483?fromshare=blogdetail&sharetype=blogdetail&sharerId=121310483&sharerefer=PC&sharesource=m0_60571820&sharefrom=from_link">https://blog.csdn.net/qq_45404853/article/details/121310483?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=121310483&amp;sharerefer=PC&amp;sharesource=m0_60571820&amp;sharefrom=from_link</a><br>windows的conda安装：<br><a href="https://blog.csdn.net/ciagrate/article/details/140129703?fromshare=blogdetail&sharetype=blogdetail&sharerId=140129703&sharerefer=PC&sharesource=m0_60571820&sharefrom=from_link">https://blog.csdn.net/ciagrate/article/details/140129703?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=140129703&amp;sharerefer=PC&amp;sharesource=m0_60571820&amp;sharefrom=from_link</a><br><strong>在powershell中识别不了conda环境是因为也需要像ubuntu中修改.bashrc一样修改powershell的配置文件。</strong></p><h2 id="原文第三部分的复现（失败）"><a href="#原文第三部分的复现（失败）" class="headerlink" title="原文第三部分的复现（失败）"></a>原文第三部分的复现（失败）</h2><p>本人在windows11上重新尝试了全文，参数是esp-idf的release&#x2F;v4.4的branch，esp-dl的idfv4.4的branch，python&#x3D;3.7，和原作者完全相同。但在执行到第二部分优化和量化模型，在前面笔记提到的三行代码处仍然失败（如下图），证明esp-dl确实有问题。<br><img src="/img/learn/20241107004007.png"><br>因此本人改变思路，既然作者自己都无法在24年复现22年的优化和量化过程，那我直接使用22年作者机缘巧合成功生成的cpp文件，直接往esp32s3里面烧录，复现第三部分模型部署，但是仍然遇到问题：</p><h3 id="cmake文件路径未标明"><a href="#cmake文件路径未标明" class="headerlink" title="cmake文件路径未标明"></a>cmake文件路径未标明</h3><p>外层 <code>CMakeLists.txt</code> 文件已经包含以下行：&#96;set(EXTRA_COMPONENT_DIRS .&#x2F;components&#x2F;esp-dl)·<br>为了确保路径一致性，建议简化路径设置：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(EXTRA_COMPONENT_DIRS $&#123;CMAKE_SOURCE_DIR&#125;/components/esp-dl)</span></span><br><span class="hljs-function"><span class="hljs-title">include_directories</span><span class="hljs-params">($&#123;CMAKE_SOURCE_DIR&#125;/components/esp-dl)</span></span><br></code></pre></td></tr></table></figure><p>在 <code>main</code> 文件夹中的 <code>CMakeLists.txt</code> 文件，可以做以下调整：<br>1、**更新 <code>include_dirs</code>**：</p><ul><li>将 <code>include_dirs</code> 添加 <code>components/esp-dl</code> 路径，以确保 <code>dl_tool.hpp</code> 能被找到。<br><code>set(include_dirs ../model $&#123;CMAKE_SOURCE_DIR&#125;/components/esp-dl)</code><br>2、<strong>检查 <code>idf_component_register</code> 设置</strong>：</li><li>更新 <code>idf_component_register</code> 部分，将 <code>INCLUDE_DIRS</code> 变量更新为刚刚修改的 <code>include_dirs</code>，确保 <code>esp-dl</code> 的头文件路径被正确添加：<br><code>idf_component_register(SRCS $&#123;srcs&#125; INCLUDE_DIRS $&#123;include_dirs&#125; REQUIRES $&#123;requires&#125;)</code></li></ul><h3 id="头文件未放置在-components-esp-dl-文件夹中"><a href="#头文件未放置在-components-esp-dl-文件夹中" class="headerlink" title="头文件未放置在.components&#x2F;esp-dl&#x2F;文件夹中"></a>头文件未放置在.components&#x2F;esp-dl&#x2F;文件夹中</h3><p><code>.hpp</code> 文件是一种 C++ 代码文件的扩展名，用来定义 C++ 的头文件（header file），类似于 <code>.h</code> 文件。本文需要将下图的esp-dl官方的头文件放到此文件夹中。<br><img src="/img/learn/2024-11-07005756.png"></p><h3 id="printf-函数的格式化字符串上（未解决）"><a href="#printf-函数的格式化字符串上（未解决）" class="headerlink" title="printf 函数的格式化字符串上（未解决）"></a><code>printf</code> 函数的格式化字符串上（未解决）</h3><p><img src="/img/learn/2024-11-07005117.png"><br>当前的代码中，以下几行使用了 <code>printf</code>，并且 <code>%u</code> 与 <code>uint32_t</code> 类型不匹配：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Latency: <span class="hljs-variable">%u</span>&quot;</span>, this-&gt;get_average_period());<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%s</span>: <span class="hljs-variable">%u</span>&quot;</span>, prefix, key, this-&gt;get_average_period());<br></code></pre></td></tr></table></figure><p>要修正这些格式化问题，需要引入 <code>&lt;inttypes.h&gt;</code> 头文件，然后使用 <code>PRIu32</code> 来替代 <code>%u</code>。这是因为 <code>PRIu32</code> 是一个与 <code>uint32_t</code> 类型兼容的格式宏。以下是修改后的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span>  <span class="hljs-comment">// 添加这个头文件</span></span><br><br><span class="hljs-type">void</span> dl::tool::Latency::<span class="hljs-built_in">print</span>() &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Latency: %&quot;</span> PRIu32 <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_average_period</span>());<br>&#125;<br><br><span class="hljs-type">void</span> dl::tool::Latency::<span class="hljs-built_in">print</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* prefix, <span class="hljs-type">uint32_t</span> key) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: %&quot;</span> PRIu32 <span class="hljs-string">&quot;\n&quot;</span>, prefix, key, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_average_period</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="后续可能解决方案"><a href="#后续可能解决方案" class="headerlink" title="后续可能解决方案"></a>后续可能解决方案</h2><p>只有放弃esp-dl，使用其他模型转化工具了。</p>]]></content>
    
    
    <categories>
      
      <category>fyp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>building_with_espdl-2-failure</title>
    <link href="/2024/11/05/model_quantization_and_optimization/"/>
    <url>/2024/11/05/model_quantization_and_optimization/</url>
    
    <content type="html"><![CDATA[<h1 id="building-with-espdl-2-failure"><a href="#building-with-espdl-2-failure" class="headerlink" title="building_with_espdl-2-failure"></a>building_with_espdl-2-failure</h1><h2 id="本人代码"><a href="#本人代码" class="headerlink" title="本人代码"></a>本人代码</h2><h3 id="正常部分"><a href="#正常部分" class="headerlink" title="正常部分"></a>正常部分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列出当前工作目录中的文件</span><br>%ls<br><br></code></pre></td></tr></table></figure><p>这部分要注意windows的python库是_<strong>.pyd</strong>形式，而linux是esp-dl的git库中同名的_<strong>.so</strong>文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入必要的库</span><br><span class="hljs-keyword">from</span> optimizer <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> calibrator <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> evaluator <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">onnx_model = onnx.load(<span class="hljs-string">&quot;handrecognition_model.onnx&quot;</span>)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">optimized_model_path = optimize_fp_model(<span class="hljs-string">&quot;handrecognition_model.onnx&quot;</span>)<br><br></code></pre></td></tr></table></figure><h4 id="打印模型的计算图信息"><a href="#打印模型的计算图信息" class="headerlink" title="打印模型的计算图信息"></a>打印模型的计算图信息</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">optimized_model = onnx.load(optimized_model_path)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Optimized ONNX model loaded successfully.&quot;</span>)<br><span class="hljs-built_in">print</span>(onnx.helper.printable_graph(optimized_model.graph))<br><br></code></pre></td></tr></table></figure><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><pre><code class="hljs">Optimized ONNX model loaded successfully.graph tf2onnx (  %conv2d_input[FLOAT, unk__33x96x96x1]) initializers (  %new_shape__31[INT64, 4]  %const_fold_opt__32[INT64, 2]  %StatefulPartitionedCall/sequential/dense_1/MatMul/ReadVariableOp:0[FLOAT, 128x6]  %StatefulPartitionedCall/sequential/dense_1/BiasAdd/ReadVariableOp:0[FLOAT, 6]  %StatefulPartitionedCall/sequential/dense/MatMul/ReadVariableOp:0[FLOAT, 6400x128]  %StatefulPartitionedCall/sequential/dense/BiasAdd/ReadVariableOp:0[FLOAT, 128]  %StatefulPartitionedCall/sequential/conv2d_2/Conv2D/ReadVariableOp:0[FLOAT, 64x64x3x3]  %StatefulPartitionedCall/sequential/conv2d_2/BiasAdd/ReadVariableOp:0[FLOAT, 64]  %StatefulPartitionedCall/sequential/conv2d_1/Conv2D/ReadVariableOp:0[FLOAT, 64x32x3x3]  %StatefulPartitionedCall/sequential/conv2d_1/BiasAdd/ReadVariableOp:0[FLOAT, 64]  %StatefulPartitionedCall/sequential/conv2d/Conv2D/ReadVariableOp:0[FLOAT, 32x1x5x5]  %StatefulPartitionedCall/sequential/conv2d/BiasAdd/ReadVariableOp:0[FLOAT, 32]) &#123;  %StatefulPartitionedCall/sequential/conv2d/BiasAdd__6:0 = Reshape(%conv2d_input, %new_shape__31)  %StatefulPartitionedCall/sequential/conv2d/BiasAdd:0 = Conv[dilations = [1, 1], group = 1, kernel_shape = [5, 5], strides = [1, 1]](%StatefulPartitionedCall/sequential/conv2d/BiasAdd__6:0, %StatefulPartitionedCall/sequential/conv2d/Conv2D/ReadVariableOp:0, %StatefulPartitionedCall/sequential/conv2d/BiasAdd/ReadVariableOp:0)  %StatefulPartitionedCall/sequential/conv2d/Relu:0 = Relu(%StatefulPartitionedCall/sequential/conv2d/BiasAdd:0)  %StatefulPartitionedCall/sequential/max_pooling2d/MaxPool:0 = MaxPool[kernel_shape = [2, 2], strides = [2, 2]](%StatefulPartitionedCall/sequential/conv2d/Relu:0)  %StatefulPartitionedCall/sequential/conv2d_1/BiasAdd:0 = Conv[dilations = [1, 1], group = 1, kernel_shape = [3, 3], strides = [1, 1]](%StatefulPartitionedCall/sequential/max_pooling2d/MaxPool:0, %StatefulPartitionedCall/sequential/conv2d_1/Conv2D/ReadVariableOp:0, %StatefulPartitionedCall/sequential/conv2d_1/BiasAdd/ReadVariableOp:0)  %StatefulPartitionedCall/sequential/conv2d_1/Relu:0 = Relu(%StatefulPartitionedCall/sequential/conv2d_1/BiasAdd:0)  %StatefulPartitionedCall/sequential/max_pooling2d_1/MaxPool:0 = MaxPool[kernel_shape = [2, 2], strides = [2, 2]](%StatefulPartitionedCall/sequential/conv2d_1/Relu:0)  %StatefulPartitionedCall/sequential/conv2d_2/BiasAdd:0 = Conv[dilations = [1, 1], group = 1, kernel_shape = [3, 3], strides = [1, 1]](%StatefulPartitionedCall/sequential/max_pooling2d_1/MaxPool:0, %StatefulPartitionedCall/sequential/conv2d_2/Conv2D/ReadVariableOp:0, %StatefulPartitionedCall/sequential/conv2d_2/BiasAdd/ReadVariableOp:0)  %StatefulPartitionedCall/sequential/conv2d_2/Relu:0 = Relu(%StatefulPartitionedCall/sequential/conv2d_2/BiasAdd:0)  %StatefulPartitionedCall/sequential/max_pooling2d_2/MaxPool:0 = MaxPool[kernel_shape = [2, 2], strides = [2, 2]](%StatefulPartitionedCall/sequential/conv2d_2/Relu:0)  %StatefulPartitionedCall/sequential/max_pooling2d_2/MaxPool__28:0 = Transpose[perm = [0, 2, 3, 1]](%StatefulPartitionedCall/sequential/max_pooling2d_2/MaxPool:0)  %StatefulPartitionedCall/sequential/flatten/Reshape:0 = Reshape(%StatefulPartitionedCall/sequential/max_pooling2d_2/MaxPool__28:0, %const_fold_opt__32)  %StatefulPartitionedCall/sequential/dense/MatMul:0 = MatMul(%StatefulPartitionedCall/sequential/flatten/Reshape:0, %StatefulPartitionedCall/sequential/dense/MatMul/ReadVariableOp:0)  %StatefulPartitionedCall/sequential/dense/BiasAdd:0 = Add(%StatefulPartitionedCall/sequential/dense/MatMul:0, %StatefulPartitionedCall/sequential/dense/BiasAdd/ReadVariableOp:0)  %StatefulPartitionedCall/sequential/dense/Relu:0 = Relu(%StatefulPartitionedCall/sequential/dense/BiasAdd:0)  %StatefulPartitionedCall/sequential/dense_1/MatMul:0 = MatMul(%StatefulPartitionedCall/sequential/dense/Relu:0, %StatefulPartitionedCall/sequential/dense_1/MatMul/ReadVariableOp:0)  %StatefulPartitionedCall/sequential/dense_1/BiasAdd:0 = Add(%StatefulPartitionedCall/sequential/dense_1/MatMul:0, %StatefulPartitionedCall/sequential/dense_1/BiasAdd/ReadVariableOp:0)  %dense_1 = Softmax(%StatefulPartitionedCall/sequential/dense_1/BiasAdd:0)  return %dense_1&#125;</code></pre><h4 id="加载pickle数据集"><a href="#加载pickle数据集" class="headerlink" title="加载pickle数据集"></a>加载pickle数据集</h4><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-comment"># 加载校准数据集</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;X_cal.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    test_images = pickle.load(f)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;y_cal.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    test_labels = pickle.load(f)<br><br><span class="hljs-comment"># 提取校准数据子集</span><br>calib_dataset = test_images[<span class="hljs-number">0</span>:<span class="hljs-number">1800</span>:<span class="hljs-number">20</span>]<br>pickle_file_path = <span class="hljs-string">&#x27;handrecognition_calib.pickle&#x27;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calibration dataset loaded and subset selected.&quot;</span>)<br><br></code></pre></td></tr></table></figure><h5 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h5><pre><code class="hljs">Calibration dataset loaded and subset selected.</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载优化后的模型</span><br>model_proto = onnx.load(optimized_model_path)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Generating the quantization table:&#x27;</span>)<br><br><span class="hljs-comment"># 初始化校准器</span><br>calib = Calibrator(<span class="hljs-string">&#x27;int16&#x27;</span>, <span class="hljs-string">&#x27;per-tensor&#x27;</span>, <span class="hljs-string">&#x27;minmax&#x27;</span>)<br><span class="hljs-comment"># 如果需要 int8 量化，可以使用以下替代代码：</span><br><span class="hljs-comment"># calib = Calibrator(&#x27;int8&#x27;, &#x27;per-channel&#x27;, &#x27;minmax&#x27;)</span><br><br><span class="hljs-comment"># 设置执行设备</span><br>calib.set_providers([<span class="hljs-string">&#x27;CPUExecutionProvider&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="报错部分"><a href="#报错部分" class="headerlink" title="报错部分"></a>报错部分</h3><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>就是这部分一直报错，不管是使用自己的1通道、10种代码，还是使用自己的3通道、6种代码，甚至直接运行原作者的model_development文件夹的model_development.ipynb和esp_dl_formate_conversionw文件夹的esp_dl_formate_conversion.py，也是失败，显示<code>ValueError: current model is not supported by esp-dl</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成量化参数</span><br>calib.generate_quantization_table(model_proto, calib_dataset, pickle_file_path)<br><br><span class="hljs-comment"># 导出系数文件</span><br>calib.export_coefficient_to_cpp(model_proto, pickle_file_path, <span class="hljs-string">&#x27;esp32s3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;handrecognition_coefficient&#x27;</span>, <span class="hljs-literal">True</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calibration and quantization completed successfully.&quot;</span>)<br><br></code></pre></td></tr></table></figure><h4 id="报错输出"><a href="#报错输出" class="headerlink" title="报错输出"></a>报错输出</h4><pre><code class="hljs">Generating the quantization table:MatMul is not supported on esp-dl yet---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)/tmp/ipykernel_107082/766837025.py in &lt;module&gt;     12      13 # 生成量化参数---&gt; 14 calib.generate_quantization_table(model_proto, calib_dataset, pickle_file_path)     15      16 # 导出系数文件~/code/gesture recognition/calibrator.so in calibrator.Calibrator.generate_quantization_table()~/code/gesture recognition/calibrator.so in calibrator.Calibrator.generate_output_model()~/code/gesture recognition/calibrator.so in calibrator.Calibrator.check_model()（执行到calibrator.Calibrator.check_model的部分有问题）ValueError: current model is not supported by esp-dl</code></pre><h3 id="尝试过的检验方向（均已失败）"><a href="#尝试过的检验方向（均已失败）" class="headerlink" title="尝试过的检验方向（均已失败）"></a>尝试过的检验方向（均已失败）</h3><h4 id="模型有效性"><a href="#模型有效性" class="headerlink" title="模型有效性"></a>模型有效性</h4><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> onnx<br>model_proto = onnx.load(optimized_model_path)<br>onnx.checker.check_model(model_proto)  <span class="hljs-comment"># 验证 ONNX 模型是否有效</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Model loaded and verified successfully.&quot;</span>)<br><br></code></pre></td></tr></table></figure><h5 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h5><pre><code class="hljs">Model loaded and verified successfully.</code></pre><h4 id="数据形状是否符合"><a href="#数据形状是否符合" class="headerlink" title="数据形状是否符合"></a>数据形状是否符合</h4><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(calib_dataset))<br><span class="hljs-built_in">print</span>(calib_dataset.shape)  <span class="hljs-comment"># 确认它的形状</span><br><span class="hljs-built_in">print</span>(calib_dataset[:<span class="hljs-number">5</span>])  <span class="hljs-comment"># 查看部分数据是否符合预期</span><br><br></code></pre></td></tr></table></figure><h5 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h5><pre><code class="hljs">&lt;class &#39;numpy.ndarray&#39;&gt;(90, 96, 96, 1)[[[[0.01176471]   [0.01568627]   [0.01568627]   ...   [0.02352941]   [0.01960784]   [0.01960784]]  [[0.01568627]   [0.01960784]   [0.01568627]   ...   [0.01960784]   [0.01568627]   [0.01176471]]  [[0.01960784]   [0.01960784]   [0.01568627]   ...   [0.01568627]   [0.01568627]   [0.01176471]]  ...  [[0.04313725]   [0.07058824]   [0.08627451]   ...   [0.01568627]   [0.01568627]   [0.01568627]]  [[0.04705882]   [0.07058824]   [0.07843137]   ...   [0.01960784]   [0.01960784]   [0.01568627]]  [[0.04705882]   [0.07058824]   [0.07843137]   ...   [0.01960784]   [0.01568627]   [0.01568627]]] [[[0.01960784]   [0.02352941]   [0.01960784]   ...   [0.01960784]   [0.01568627]   [0.01568627]]  [[0.01568627]   [0.01568627]   [0.01960784]   ...   [0.01568627]   [0.01960784]   [0.01176471]]  [[0.01960784]   [0.01960784]   [0.02352941]   ...   [0.01568627]   [0.01568627]   [0.01568627]]  ...  [[0.01960784]   [0.01960784]   [0.01960784]   ...   [0.01960784]   [0.01960784]   [0.01960784]]  [[0.01568627]   [0.01960784]   [0.01960784]   ...   [0.01176471]   [0.01568627]   [0.01568627]]  [[0.01960784]   [0.01960784]   [0.01960784]   ...   [0.01960784]   [0.01960784]   [0.01568627]]] [[[0.02352941]   [0.01960784]   [0.02352941]   ...   [0.02352941]   [0.02352941]   [0.02352941]]  [[0.02352941]   [0.02352941]   [0.02745098]   ...   [0.02352941]   [0.02352941]   [0.01568627]]  [[0.02352941]   [0.02352941]   [0.01960784]   ...   [0.01960784]   [0.01960784]   [0.02352941]]  ...  [[0.01960784]   [0.01960784]   [0.02352941]   ...   [0.02352941]   [0.01960784]   [0.01960784]]  [[0.01568627]   [0.01960784]   [0.01960784]   ...   [0.02352941]   [0.02352941]   [0.02745098]]  [[0.02352941]   [0.02352941]   [0.02352941]   ...   [0.02352941]   [0.02352941]   [0.03137255]]] [[[0.01568627]   [0.01960784]   [0.01960784]   ...   [0.01568627]   [0.01960784]   [0.01568627]]  [[0.01176471]   [0.01960784]   [0.01568627]   ...   [0.01568627]   [0.01568627]   [0.01176471]]  [[0.01960784]   [0.01960784]   [0.01960784]   ...   [0.01176471]   [0.01568627]   [0.01568627]]  ...  [[0.06666667]   [0.05882353]   [0.06666667]   ...   [0.01960784]   [0.01568627]   [0.01568627]]  [[0.05882353]   [0.05490196]   [0.05882353]   ...   [0.01568627]   [0.01568627]   [0.01568627]]  [[0.05098039]   [0.05098039]   [0.0627451 ]   ...   [0.01960784]   [0.01568627]   [0.02352941]]] [[[0.02745098]   [0.01960784]   [0.02352941]   ...   [0.01568627]   [0.01568627]   [0.01568627]]  [[0.01960784]   [0.01960784]   [0.02352941]   ...   [0.01960784]   [0.01568627]   [0.01960784]]  [[0.01568627]   [0.01960784]   [0.01960784]   ...   [0.01568627]   [0.01568627]   [0.01568627]]  ...  [[0.01568627]   [0.01568627]   [0.01960784]   ...   [0.01568627]   [0.01960784]   [0.01568627]]  [[0.02352941]   [0.01960784]   [0.01960784]   ...   [0.01568627]   [0.01960784]   [0.01568627]]  [[0.01960784]   [0.01568627]   [0.01568627]   ...   [0.01960784]   [0.01568627]   [0.02352941]]]]</code></pre><h4 id="pickel路径有效性"><a href="#pickel路径有效性" class="headerlink" title="pickel路径有效性"></a>pickel路径有效性</h4><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 设置文件路径</span><br>pickle_file_path = <span class="hljs-string">&#x27;output/handrecognition_calib_params.pickle&#x27;</span><br><br><span class="hljs-comment"># 检查路径是否存在，不存在则创建</span><br>output_dir = os.path.dirname(pickle_file_path)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_dir):<br>    os.makedirs(output_dir)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Created directory: <span class="hljs-subst">&#123;output_dir&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 检查是否可写</span><br>is_writeable = os.access(output_dir, os.W_OK)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Writable:&quot;</span>, is_writeable)<br><br></code></pre></td></tr></table></figure><h5 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h5><pre><code class="hljs">Writable: True</code></pre><p>在第一次显示不可写并且创建了文件夹以后，仍然无法被esp-dl支持，因此也不是读写性的问题。</p><h2 id="原作者代码运行证明失败"><a href="#原作者代码运行证明失败" class="headerlink" title="原作者代码运行证明失败"></a>原作者代码运行证明失败</h2><p>这部分我把原作者esp_dl_formate_conversion.py拆开到jupyter notebook中创建ipynb（当然前面模型训练部分也是直接使用model_development.ipynb），一步一步执行，最终同样卡在了同样的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#import libraries </span><br><span class="hljs-keyword">from</span> optimizer <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> calibrator <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> evaluator <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> pickle<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#load ONNX model </span><br>onnx_model = onnx.load(<span class="hljs-string">&quot;handrecognition_model.onnx&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#optimize ONNX model </span><br>optimized_model_path = optimize_fp_model(<span class="hljs-string">&quot;handrecognition_model.onnx&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#load calibration dataset</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;X_cal.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    (test_images) = pickle.load(f)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;y_cal.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    (test_labels) = pickle.load(f)<br><br>calib_dataset = test_images[<span class="hljs-number">0</span>:<span class="hljs-number">1800</span>:<span class="hljs-number">20</span>]<br>pickle_file_path = <span class="hljs-string">&#x27;handrecognition_calib.pickle&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#calibration </span><br>model_proto = onnx.load(optimized_model_path)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Generating the quantization table:&#x27;</span>)<br>calib = Calibrator(<span class="hljs-string">&#x27;int16&#x27;</span>, <span class="hljs-string">&#x27;per-tensor&#x27;</span>, <span class="hljs-string">&#x27;minmax&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Generating the quantization table:</code></pre><h3 id="出错位置"><a href="#出错位置" class="headerlink" title="出错位置"></a>出错位置</h3><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">###for in8 conversion </span><br><span class="hljs-comment">#calib = Calibrator(&#x27;int8&#x27;, &#x27;per-channel&#x27;, &#x27;minmax&#x27;) </span><br><br>calib.set_providers([<span class="hljs-string">&#x27;CPUExecutionProvider&#x27;</span>])<br><span class="hljs-comment"># Obtain the quantization parameter</span><br>calib.generate_quantization_table(model_proto,calib_dataset, pickle_file_path)<br><span class="hljs-comment"># Generate the coefficient files for esp32s3</span><br>calib.export_coefficient_to_cpp(model_proto,  pickle_file_path, <span class="hljs-string">&#x27;esp32s3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;handrecognition_coefficient&#x27;</span>, <span class="hljs-literal">True</span>)<br><br></code></pre></td></tr></table></figure><h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><pre><code class="hljs">MatMul is not supported on esp-dl yet---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)/tmp/ipykernel_102222/2534009994.py in &lt;module&gt;      5 calib.set_providers([&#39;CPUExecutionProvider&#39;])      6 # Obtain the quantization parameter----&gt; 7 calib.generate_quantization_table(model_proto,calib_dataset, pickle_file_path)      8 # Generate the coefficient files for esp32s3      9 calib.export_coefficient_to_cpp(model_proto,  pickle_file_path, &#39;esp32s3&#39;, &#39;.&#39;, &#39;handrecognition_coefficient&#39;, True)~/code/Blogs/ESP-DL/esp_dl_formate_conversion/calibrator.so in calibrator.Calibrator.generate_quantization_table()~/code/Blogs/ESP-DL/esp_dl_formate_conversion/calibrator.so in calibrator.Calibrator.generate_output_model()~/code/Blogs/ESP-DL/esp_dl_formate_conversion/calibrator.so in calibrator.Calibrator.check_model()ValueError: current model is not supported by esp-dl</code></pre><p>最终，感谢在薛兄的提醒下，发现有人给作者提过这个问题，但作者至今也并未解决：<a href="https://github.com/alibukharai/Blogs/issues/9">https://github.com/alibukharai/Blogs/issues/9</a><br><img src="/img/learn/2024-11-05172636.png"></p><h2 id="考虑可能成功的新方向"><a href="#考虑可能成功的新方向" class="headerlink" title="考虑可能成功的新方向"></a>考虑可能成功的新方向</h2><ul><li>在windows中搭conda尝试，因为之前只在ubuntu 24.04中尝试过，有可能esp-dl官方库的.pyd能成功，只是.so文件有问题。</li><li>更换esp-idf和esp-dl的branch和tag，因为目前使用的是v5.3的idf和release&#x2F;v1.1的dl，原作者采用的是v4.4的idf和idf4.4的idf。</li><li>使用其他的优化和量化模型的工具，esp-dl确实不是很完善。</li></ul>]]></content>
    
    
    <categories>
      
      <category>fyp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>building_with_espdl-1-supplement</title>
    <link href="/2024/11/05/generate_calibration_data/"/>
    <url>/2024/11/05/generate_calibration_data/</url>
    
    <content type="html"><![CDATA[<h1 id="building-with-espdl-1-supplement"><a href="#building-with-espdl-1-supplement" class="headerlink" title="building_with_espdl-1-supplement"></a>building_with_espdl-1-supplement</h1><p>因为模型优化和量化部分需要X_cal.pkl和y_cal.pkl文件，而在第一部分训练模型时未生成，因此新建一个项目生成pkl。</p><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-comment"># 设置图片的尺寸和批量大小</span><br>img_height, img_width = <span class="hljs-number">96</span>, <span class="hljs-number">96</span><br>batch_size = <span class="hljs-number">16</span><br><br><span class="hljs-comment"># 数据集根目录</span><br>data_dir = <span class="hljs-string">&quot;./leapGestRecog&quot;</span>  <span class="hljs-comment"># 请替换为你的实际路径</span><br><br><span class="hljs-comment"># 加载和预处理数据集</span><br>train_ds = tf.keras.preprocessing.image_dataset_from_directory(<br>    data_dir,<br>    validation_split=<span class="hljs-number">0.2</span>,<br>    subset=<span class="hljs-string">&quot;training&quot;</span>,<br>    seed=<span class="hljs-number">123</span>,<br>    image_size=(img_height, img_width),<br>    batch_size=batch_size<br>)<br><br>val_ds = tf.keras.preprocessing.image_dataset_from_directory(<br>    data_dir,<br>    validation_split=<span class="hljs-number">0.2</span>,<br>    subset=<span class="hljs-string">&quot;validation&quot;</span>,<br>    seed=<span class="hljs-number">123</span>,<br>    image_size=(img_height, img_width),<br>    batch_size=batch_size<br>)<br><br><span class="hljs-comment"># 创建用于保存数据的列表</span><br>X_cal = []<br>y_cal = []<br><br><span class="hljs-comment"># 遍历训练集，将图像和标签存储到列表中</span><br><span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> train_ds:<br>    X_cal.append(images.numpy())<br>    y_cal.append(labels.numpy())<br><br><span class="hljs-comment"># 遍历验证集，将图像和标签存储到列表中</span><br><span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> val_ds:<br>    X_cal.append(images.numpy())<br>    y_cal.append(labels.numpy())<br><br><span class="hljs-comment"># 将列表转换为 NumPy 数组</span><br>X_cal = np.concatenate(X_cal)<br>y_cal = np.concatenate(y_cal)<br><br><span class="hljs-comment"># 保存为 pickle 文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;X_cal.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(X_cal, f)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;y_cal.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(y_cal, f)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;X_cal.pkl 和 y_cal.pkl 已成功创建。&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="次版"><a href="#次版" class="headerlink" title="次版"></a>次版</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>原因同模型训练部分，因此修改3通道改为1通道。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-comment"># 设置图片的尺寸和批量大小</span><br>img_height, img_width = <span class="hljs-number">96</span>, <span class="hljs-number">96</span><br>batch_size = <span class="hljs-number">16</span><br><br><span class="hljs-comment"># 数据集根目录</span><br>data_dir = <span class="hljs-string">&quot;./leapGestRecog&quot;</span>  <span class="hljs-comment"># 请替换为你的实际路径</span><br><br><span class="hljs-comment"># 加载和预处理数据集</span><br>train_ds = tf.keras.preprocessing.image_dataset_from_directory(<br>    data_dir,<br>    validation_split=<span class="hljs-number">0.2</span>,<br>    subset=<span class="hljs-string">&quot;training&quot;</span>,<br>    seed=<span class="hljs-number">123</span>,<br>    image_size=(img_height, img_width),<br>    batch_size=batch_size<br>)<br><br>val_ds = tf.keras.preprocessing.image_dataset_from_directory(<br>    data_dir,<br>    validation_split=<span class="hljs-number">0.2</span>,<br>    subset=<span class="hljs-string">&quot;validation&quot;</span>,<br>    seed=<span class="hljs-number">123</span>,<br>    image_size=(img_height, img_width),<br>    batch_size=batch_size<br>)<br><br><span class="hljs-comment"># 转换为灰度图并归一化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">normalize_img</span>(<span class="hljs-params">image, label</span>):<br>    image = tf.image.rgb_to_grayscale(image)  <span class="hljs-comment"># 转换为灰度</span><br>    image = tf.cast(image, tf.float32) / <span class="hljs-number">255.0</span>  <span class="hljs-comment"># 归一化到 [0, 1]</span><br>    <span class="hljs-keyword">return</span> image, label<br><br><span class="hljs-comment"># 应用转换函数到数据集</span><br>train_ds = train_ds.<span class="hljs-built_in">map</span>(normalize_img)<br>val_ds = val_ds.<span class="hljs-built_in">map</span>(normalize_img)<br><br><span class="hljs-comment"># 创建用于保存数据的列表</span><br>X_cal = []<br>y_cal = []<br><br><span class="hljs-comment"># 遍历训练集，将图像和标签存储到列表中</span><br><span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> train_ds:<br>    X_cal.append(images.numpy())<br>    y_cal.append(labels.numpy())<br><br><span class="hljs-comment"># 遍历验证集，将图像和标签存储到列表中</span><br><span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> val_ds:<br>    X_cal.append(images.numpy())<br>    y_cal.append(labels.numpy())<br><br><span class="hljs-comment"># 将列表转换为 NumPy 数组</span><br>X_cal = np.concatenate(X_cal)<br>y_cal = np.concatenate(y_cal)<br><br><span class="hljs-comment"># 保存为 pickle 文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;X_cal.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(X_cal, f)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;y_cal.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(y_cal, f)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;X_cal.pkl 和 y_cal.pkl 已成功创建。&quot;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>手动遍历文件系统以加载数据，仅选择前 6 个手势类别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-comment"># 设置数据集目录和参数</span><br>data_dir = <span class="hljs-string">&quot;./leapGestRecog&quot;</span>  <span class="hljs-comment"># 请替换为你的实际路径</span><br>img_height, img_width = <span class="hljs-number">96</span>, <span class="hljs-number">96</span><br><br><span class="hljs-comment"># 定义需要加载的手势类别（仅加载前6类）</span><br>selected_gestures = [<span class="hljs-string">&quot;01_palm&quot;</span>, <span class="hljs-string">&quot;02_l&quot;</span>, <span class="hljs-string">&quot;03_fist&quot;</span>, <span class="hljs-string">&quot;04_fist_moved&quot;</span>, <span class="hljs-string">&quot;05_thumb&quot;</span>, <span class="hljs-string">&quot;06_index&quot;</span>]<br><br><span class="hljs-comment"># 初始化数据和标签列表</span><br>X_cal = []<br>y_cal = []<br><br><span class="hljs-comment"># 遍历每个顶层文件夹（例如 00, 01...）</span><br><span class="hljs-keyword">for</span> subdir <span class="hljs-keyword">in</span> os.listdir(data_dir):<br>    subdir_path = os.path.join(data_dir, subdir)<br>    <br>    <span class="hljs-comment"># 确保顶层文件夹是目录</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isdir(subdir_path):<br>        <span class="hljs-keyword">continue</span><br>    <br>    <span class="hljs-comment"># 仅遍历前六个手势类别文件夹</span><br>    <span class="hljs-keyword">for</span> idx, gesture <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(selected_gestures):<br>        gesture_path = os.path.join(subdir_path, gesture)<br>        <br>        <span class="hljs-comment"># 确保手势文件夹存在</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isdir(gesture_path):<br>            <span class="hljs-keyword">continue</span><br>        <br>        <span class="hljs-comment"># 遍历每张图像文件</span><br>        <span class="hljs-keyword">for</span> img_file <span class="hljs-keyword">in</span> os.listdir(gesture_path):<br>            img_path = os.path.join(gesture_path, img_file)<br>            <br>            <span class="hljs-comment"># 读取图像，转换为灰度，并调整大小</span><br>            img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)<br>            img_resized = cv2.resize(img, (img_width, img_height))<br>            <br>            <span class="hljs-comment"># 归一化图像数据</span><br>            img_normalized = img_resized / <span class="hljs-number">255.0</span><br>            X_cal.append(img_normalized)<br>            y_cal.append(idx)  <span class="hljs-comment"># 使用手势的索引作为标签</span><br><br><span class="hljs-comment"># 转换为 NumPy 数组，并调整维度</span><br>X_cal = np.array(X_cal).reshape(-<span class="hljs-number">1</span>, img_height, img_width, <span class="hljs-number">1</span>)<br>y_cal = np.array(y_cal)<br><br><span class="hljs-comment"># 保存为 pickle 文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;X_cal.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(X_cal, f)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;y_cal.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(y_cal, f)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;X_cal.pkl 和 y_cal.pkl 已成功创建，包含前6个手势类别的数据。&quot;</span>)<br><br></code></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code class="hljs">X_cal.pkl 和 y_cal.pkl 已成功创建，包含前6个手势类别的数据。</code></pre>]]></content>
    
    
    <categories>
      
      <category>fyp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>building_with_espdl-1-success</title>
    <link href="/2024/11/02/chatgpt_version1/"/>
    <url>/2024/11/02/chatgpt_version1/</url>
    
    <content type="html"><![CDATA[<h1 id="building-with-espdl-1-success"><a href="#building-with-espdl-1-success" class="headerlink" title="building_with_espdl-1-success"></a>building_with_espdl-1-success</h1><p>基本完成原文第1部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Import necessary libraries</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Conv2D, MaxPooling2D, Flatten, Dense<br><span class="hljs-keyword">from</span> keras.utils <span class="hljs-keyword">import</span> to_categorical<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-comment"># Load the dataset (you may need to download it manually from Kaggle and upload to Colab)</span><br><span class="hljs-comment"># Assuming you have a folder &#x27;gestures&#x27; with images sorted in subdirectories</span><br>data_dir = <span class="hljs-string">&quot;./leapgestrecog/leapGestRecog&quot;</span>  <span class="hljs-comment"># 修改此处，指定手势数据集的路径</span><br><br></code></pre></td></tr></table></figure><h2 id="处理数据集部分"><a href="#处理数据集部分" class="headerlink" title="处理数据集部分"></a>处理数据集部分</h2><h3 id="无用1"><a href="#无用1" class="headerlink" title="无用1"></a>无用1</h3><p>这一段代码可无需理会，因为在和gpt交流的过程中，明白了pkl也只是原作者切割并且整理好的数据集，我这里可以完全不采用，并且原作中导入数据集的方法较为繁琐，此处也有更简单的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> img_to_array<br><br><span class="hljs-comment"># 数据集根目录</span><br>data_dir = <span class="hljs-string">&quot;./leapgestrecog/leapGestRecog&quot;</span>  <span class="hljs-comment"># 请替换为你的实际路径</span><br><br><span class="hljs-comment"># 定义类别标签映射（根据你的数据集的第二层目录进行映射）</span><br>class_labels = &#123;<br>    <span class="hljs-string">&#x27;01_palm&#x27;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&#x27;02_l&#x27;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&#x27;03_fist&#x27;</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&#x27;04_fist_moved&#x27;</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-string">&#x27;05_thumb&#x27;</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-string">&#x27;06_index&#x27;</span>: <span class="hljs-number">5</span>,<br>    <span class="hljs-string">&#x27;07_ok&#x27;</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-string">&#x27;08_palm_moved&#x27;</span>: <span class="hljs-number">7</span>,<br>    <span class="hljs-string">&#x27;09_c&#x27;</span>: <span class="hljs-number">8</span>,<br>    <span class="hljs-string">&#x27;10_down&#x27;</span>: <span class="hljs-number">9</span><br>&#125;<br><br><span class="hljs-comment"># 初始化图像路径和标签的列表</span><br>image_paths = []<br>labels = []<br><br><span class="hljs-comment"># 遍历第一层文件夹</span><br><span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span> os.listdir(data_dir):<br>    folder_path = os.path.join(data_dir, folder)<br>    <span class="hljs-keyword">if</span> os.path.isdir(folder_path):  <span class="hljs-comment"># 确保是文件夹</span><br>        <span class="hljs-comment"># 遍历第二层文件夹</span><br>        <span class="hljs-keyword">for</span> class_name, label <span class="hljs-keyword">in</span> class_labels.items():<br>            class_folder_path = os.path.join(folder_path, class_name)<br>            <span class="hljs-keyword">if</span> os.path.isdir(class_folder_path):<br>                <span class="hljs-comment"># 遍历图像文件</span><br>                <span class="hljs-keyword">for</span> img_file <span class="hljs-keyword">in</span> os.listdir(class_folder_path):<br>                    img_path = os.path.join(class_folder_path, img_file)<br>                    image_paths.append(img_path)<br>                    labels.append(label)<br><br><span class="hljs-comment"># 设置图像尺寸</span><br>img_height, img_width = <span class="hljs-number">96</span>, <span class="hljs-number">96</span><br><br><span class="hljs-comment"># 加载图像并转换为数组</span><br>images = []<br><span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> image_paths:<br>    <span class="hljs-keyword">try</span>:<br>        img = Image.<span class="hljs-built_in">open</span>(path).convert(<span class="hljs-string">&#x27;RGB&#x27;</span>)<br>        img = img.resize((img_width, img_height))<br>        img_array = img_to_array(img) / <span class="hljs-number">255.0</span>  <span class="hljs-comment"># 归一化</span><br>        images.append(img_array)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;无法处理图像 <span class="hljs-subst">&#123;path&#125;</span>: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 转换为 NumPy 数组</span><br>X = np.array(images)<br>y = np.array(labels)<br><br><span class="hljs-comment"># 划分训练集、验证集和测试集</span><br>ts = <span class="hljs-number">0.3</span>  <span class="hljs-comment"># 30% 的数据作为测试集</span><br>X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=ts, random_state=<span class="hljs-number">42</span>)<br>X_test, X_cal, y_test, y_cal = train_test_split(X_temp, y_temp, test_size=<span class="hljs-number">0.5</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 检查数据集形状</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集样本数:&quot;</span>, X_train.shape[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试集样本数:&quot;</span>, X_test.shape[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;校准集样本数:&quot;</span>, X_cal.shape[<span class="hljs-number">0</span>])<br><br></code></pre></td></tr></table></figure><h3 id="简化的切割、标注、导入数据集的方法"><a href="#简化的切割、标注、导入数据集的方法" class="headerlink" title="简化的切割、标注、导入数据集的方法"></a>简化的切割、标注、导入数据集的方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置图片的尺寸和批量大小</span><br>img_height, img_width = <span class="hljs-number">96</span>, <span class="hljs-number">96</span>  <span class="hljs-comment"># 按照文档中的建议将图像调整为 (96, 96)</span><br>batch_size = <span class="hljs-number">16</span><br><br><span class="hljs-comment"># 加载和预处理数据集</span><br>train_ds = tf.keras.preprocessing.image_dataset_from_directory(<br>    data_dir,<br>    validation_split=<span class="hljs-number">0.2</span>,  <span class="hljs-comment"># 将20%数据作为验证集</span><br>    subset=<span class="hljs-string">&quot;training&quot;</span>,<br>    seed=<span class="hljs-number">123</span>,  <span class="hljs-comment"># 保证数据划分的可重复性</span><br>    image_size=(img_height, img_width),<br>    batch_size=batch_size<br>)<br><br>val_ds = tf.keras.preprocessing.image_dataset_from_directory(<br>    data_dir,<br>    validation_split=<span class="hljs-number">0.2</span>,<br>    subset=<span class="hljs-string">&quot;validation&quot;</span>,<br>    seed=<span class="hljs-number">123</span>,<br>    image_size=(img_height, img_width),<br>    batch_size=batch_size<br>)<br><br><span class="hljs-comment"># 缓存和优化数据加载，以提高训练速度</span><br>AUTOTUNE = tf.data.AUTOTUNE<br>train_ds = train_ds.cache().shuffle(<span class="hljs-number">1000</span>).prefetch(buffer_size=AUTOTUNE)<br>val_ds = val_ds.cache().prefetch(buffer_size=AUTOTUNE)<br><br></code></pre></td></tr></table></figure><h3 id="像素值必须归一化，否则无法收敛"><a href="#像素值必须归一化，否则无法收敛" class="headerlink" title="像素值必须归一化，否则无法收敛"></a>像素值必须归一化，否则无法收敛</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 插入归一化代码</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">normalize_img</span>(<span class="hljs-params">image, label</span>):<br>    image = tf.cast(image, tf.float32) / <span class="hljs-number">255.0</span>  <span class="hljs-comment"># 将像素值归一化到 [0, 1]</span><br>    <span class="hljs-keyword">return</span> image, label<br><br><span class="hljs-comment"># 应用归一化到数据集</span><br>train_ds = train_ds.<span class="hljs-built_in">map</span>(normalize_img)<br>val_ds = val_ds.<span class="hljs-built_in">map</span>(normalize_img)<br></code></pre></td></tr></table></figure><h3 id="无用2，一开始是为了检查gpt声称简化的切割方法和原作者的方法得到的样本量差距大不大，若不大则可以使用简化方法"><a href="#无用2，一开始是为了检查gpt声称简化的切割方法和原作者的方法得到的样本量差距大不大，若不大则可以使用简化方法" class="headerlink" title="无用2，一开始是为了检查gpt声称简化的切割方法和原作者的方法得到的样本量差距大不大，若不大则可以使用简化方法"></a>无用2，一开始是为了检查gpt声称简化的切割方法和原作者的方法得到的样本量差距大不大，若不大则可以使用简化方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检查样本数是否一致</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;使用 image_dataset_from_directory 分割的数据集：&quot;</span>)<br>train_count = tf.data.experimental.cardinality(train_ds).numpy() * batch_size<br>val_count = tf.data.experimental.cardinality(val_ds).numpy() * batch_size<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;训练集样本数: <span class="hljs-subst">&#123;train_count&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;验证集样本数: <span class="hljs-subst">&#123;val_count&#125;</span>&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;使用 train_test_split 分割的数据集：&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;训练集样本数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(X_train)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;测试集样本数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(X_test)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;校准集样本数: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(X_cal)&#125;</span>&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="cnn算法部分"><a href="#cnn算法部分" class="headerlink" title="cnn算法部分"></a>cnn算法部分</h2><p>*必须注意这里原作者只抽取了kaggle数据集中的6种，但我用了全部10种，一开始也直接复制代码写的<code>Dense(6</code>，但实际上应该是<code>Dense(10</code>。</p><h3 id="这一段是由gpt给出的版本，和原作者类似-属于链式调用"><a href="#这一段是由gpt给出的版本，和原作者类似-属于链式调用" class="headerlink" title="这一段是由gpt给出的版本，和原作者类似,属于链式调用"></a>这一段是由gpt给出的版本，和原作者类似,属于链式调用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Conv2D, MaxPooling2D, Flatten, Dense, Dropout<br><br>model = Sequential([<br>    Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(<span class="hljs-number">96</span>, <span class="hljs-number">96</span>, <span class="hljs-number">3</span>)),<br>    MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)),<br>    Dropout(<span class="hljs-number">0.2</span>),<br><br>    Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>    MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)),<br>    Dropout(<span class="hljs-number">0.2</span>),<br><br>    Conv2D(<span class="hljs-number">128</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>    MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)),<br>    Dropout(<span class="hljs-number">0.2</span>),<br><br>    Flatten(),<br>    Dense(<span class="hljs-number">128</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>    Dropout(<span class="hljs-number">0.2</span>),<br>    Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)<br>])<br><br></code></pre></td></tr></table></figure><h3 id="无用3，这是原作者部分，属于逐层添加"><a href="#无用3，这是原作者部分，属于逐层添加" class="headerlink" title="无用3，这是原作者部分，属于逐层添加"></a>无用3，这是原作者部分，属于逐层添加</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Conv2D, MaxPooling2D, Flatten, Dense, Dropout<br><br>model = Sequential()<br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(<span class="hljs-number">96</span>, <span class="hljs-number">96</span>, <span class="hljs-number">3</span>)))<br>model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>model.add(Dropout(<span class="hljs-number">0.2</span>))<br><br>model.add(Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>model.add(Dropout(<span class="hljs-number">0.2</span>))<br><br>model.add(Conv2D(<span class="hljs-number">128</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>model.add(Dropout(<span class="hljs-number">0.2</span>))<br><br>model.add(Flatten())<br>model.add(Dense(<span class="hljs-number">128</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(Dropout(<span class="hljs-number">0.2</span>))<br>model.add(Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>))<br><br></code></pre></td></tr></table></figure><h3 id="这部分可以去掉，但输出结构摘要可以与原作者的过程相对比"><a href="#这部分可以去掉，但输出结构摘要可以与原作者的过程相对比" class="headerlink" title="这部分可以去掉，但输出结构摘要可以与原作者的过程相对比"></a>这部分可以去掉，但输出结构摘要可以与原作者的过程相对比</h3><p><strong>这里要强调的是原作者用的是96,96,1的灰度图（最后一个数字表示通道数），而本文采用的是96,96,3的三通道的彩色图，会使参数多一些，但影响不大。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输出模型结构摘要</span><br>model.summary()<br><br></code></pre></td></tr></table></figure><h2 id="模型的编译部分"><a href="#模型的编译部分" class="headerlink" title="模型的编译部分"></a>模型的编译部分</h2><h3 id="这一段是我采用的模型编译部分"><a href="#这一段是我采用的模型编译部分" class="headerlink" title="这一段是我采用的模型编译部分"></a>这一段是我采用的模型编译部分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 编译模型</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;sparse_categorical_crossentropy&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><br><span class="hljs-comment"># 模型训练</span><br>epochs = <span class="hljs-number">5</span>  <span class="hljs-comment"># 设置训练轮数</span><br><br><span class="hljs-comment"># 使用 train_ds 和 val_ds 进行训练</span><br>history = model.fit(<br>    train_ds,  <span class="hljs-comment"># 使用训练集数据集对象</span><br>    epochs=epochs,<br>    validation_data=val_ds,  <span class="hljs-comment"># 使用验证集数据集对象</span><br>    verbose=<span class="hljs-number">1</span><br>)<br><br></code></pre></td></tr></table></figure><h3 id="无用4，这一段是修改原作者的"><a href="#无用4，这一段是修改原作者的" class="headerlink" title="无用4，这一段是修改原作者的"></a>无用4，这一段是修改原作者的</h3><p>因为从导入数据集那里就产生了区别，我在导入的过程中并没有产生X_train、y_train这类变量，因此也不使用这段代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 编译模型</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;sparse_categorical_crossentropy&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><br><span class="hljs-comment"># 训练参数设置</span><br>epochs = <span class="hljs-number">10</span>  <span class="hljs-comment"># 设置训练轮数，可以根据需求调整</span><br>batch_size = <span class="hljs-number">32</span>  <span class="hljs-comment"># 每批次的样本数量</span><br><br><span class="hljs-comment"># 使用训练集和验证集进行训练</span><br>history = model.fit(<br>    X_train, y_train,  <span class="hljs-comment"># 训练集数据</span><br>    epochs=epochs,<br>    batch_size=batch_size,<br>    validation_data=(X_test, y_test),  <span class="hljs-comment"># 验证集数据</span><br>    verbose=<span class="hljs-number">1</span><br>)<br><br></code></pre></td></tr></table></figure><h2 id="拍错部分，分别从不同可能导致精确度提升不上去的角度进行排查"><a href="#拍错部分，分别从不同可能导致精确度提升不上去的角度进行排查" class="headerlink" title="拍错部分，分别从不同可能导致精确度提升不上去的角度进行排查"></a>拍错部分，分别从不同可能导致精确度提升不上去的角度进行排查</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看训练集和验证集标签的示例数据类型</span><br><span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> train_ds.take(<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集标签数据类型:&quot;</span>, labels.dtype)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集标签示例:&quot;</span>, labels.numpy()[:<span class="hljs-number">10</span>])<br><br><span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> val_ds.take(<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;验证集标签数据类型:&quot;</span>, labels.dtype)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;验证集标签示例:&quot;</span>, labels.numpy()[:<span class="hljs-number">10</span>])<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看训练集和验证集图像的示例数据范围</span><br><span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> train_ds.take(<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集图像数据最小值:&quot;</span>, images.numpy().<span class="hljs-built_in">min</span>())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集图像数据最大值:&quot;</span>, images.numpy().<span class="hljs-built_in">max</span>())<br><br><span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> val_ds.take(<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;验证集图像数据最小值:&quot;</span>, images.numpy().<span class="hljs-built_in">min</span>())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;验证集图像数据最大值:&quot;</span>, images.numpy().<span class="hljs-built_in">max</span>())<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看训练集和验证集的结构</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集数据集对象:&quot;</span>, train_ds)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;验证集数据集对象:&quot;</span>, val_ds)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在归一化之后，检查是否有 NaN 或 Inf 值</span><br><span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> train_ds.take(<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集图像中是否存在 NaN:&quot;</span>, np.isnan(images.numpy()).<span class="hljs-built_in">any</span>())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集图像中是否存在 Inf:&quot;</span>, np.isinf(images.numpy()).<span class="hljs-built_in">any</span>())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集标签中是否存在 NaN:&quot;</span>, np.isnan(labels.numpy()).<span class="hljs-built_in">any</span>())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集标签中是否存在 Inf:&quot;</span>, np.isinf(labels.numpy()).<span class="hljs-built_in">any</span>())<br><br></code></pre></td></tr></table></figure><h2 id="查看训练过程的历史记录，但我只在失败后用过，成功后还没有运行"><a href="#查看训练过程的历史记录，但我只在失败后用过，成功后还没有运行" class="headerlink" title="查看训练过程的历史记录，但我只在失败后用过，成功后还没有运行"></a>查看训练过程的历史记录，但我只在失败后用过，成功后还没有运行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 检查是否存在历史记录</span><br><span class="hljs-keyword">if</span> history.history:<br>    <span class="hljs-comment"># 绘制训练和验证准确率</span><br>    plt.plot(history.history[<span class="hljs-string">&#x27;accuracy&#x27;</span>], label=<span class="hljs-string">&#x27;训练准确率&#x27;</span>)<br>    plt.plot(history.history[<span class="hljs-string">&#x27;val_accuracy&#x27;</span>], label=<span class="hljs-string">&#x27;验证准确率&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;训练轮次&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;准确率&#x27;</span>)<br>    plt.legend()<br>    plt.show()<br><br>    <span class="hljs-comment"># 绘制训练和验证损失</span><br>    plt.plot(history.history[<span class="hljs-string">&#x27;loss&#x27;</span>], label=<span class="hljs-string">&#x27;训练损失&#x27;</span>)<br>    plt.plot(history.history[<span class="hljs-string">&#x27;val_loss&#x27;</span>], label=<span class="hljs-string">&#x27;验证损失&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;训练轮次&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;损失&#x27;</span>)<br>    plt.legend()<br>    plt.show()<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有历史记录，可能训练过程中出现错误。&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="自我完整代码"><a href="#自我完整代码" class="headerlink" title="自我完整代码"></a>自我完整代码</h2><h3 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h3><p>唯一做的微调是batch_size和学习率<del>学习率目前在我看来对我影响不大</del>，一开始accuracy上不去的愿意一个是Dense设置不对，还有一个是没有归一化。batch_size的影响在下一节提到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Conv2D, MaxPooling2D, Flatten, Dense, Dropout<br><br><span class="hljs-comment"># 设置图片的尺寸和批量大小</span><br>img_height, img_width = <span class="hljs-number">96</span>, <span class="hljs-number">96</span><br>batch_size = <span class="hljs-number">16</span>  <span class="hljs-comment"># 为了适应4GB显存，将批量大小设置为16</span><br><br><span class="hljs-comment"># 数据集根目录</span><br>data_dir = <span class="hljs-string">&quot;./leapgestrecog/leapGestRecog&quot;</span>  <span class="hljs-comment"># 请替换为你的实际路径</span><br><br><span class="hljs-comment"># 加载和预处理数据集</span><br>train_ds = tf.keras.preprocessing.image_dataset_from_directory(<br>    data_dir,<br>    validation_split=<span class="hljs-number">0.2</span>,  <span class="hljs-comment"># 将20%数据作为验证集</span><br>    subset=<span class="hljs-string">&quot;training&quot;</span>,<br>    seed=<span class="hljs-number">123</span>,  <span class="hljs-comment"># 保证数据划分的可重复性</span><br>    image_size=(img_height, img_width),<br>    batch_size=batch_size<br>)<br><br>val_ds = tf.keras.preprocessing.image_dataset_from_directory(<br>    data_dir,<br>    validation_split=<span class="hljs-number">0.2</span>,<br>    subset=<span class="hljs-string">&quot;validation&quot;</span>,<br>    seed=<span class="hljs-number">123</span>,<br>    image_size=(img_height, img_width),<br>    batch_size=batch_size<br>)<br><br><span class="hljs-comment"># 缓存和优化数据加载，以提高训练速度</span><br>AUTOTUNE = tf.data.AUTOTUNE<br>train_ds = train_ds.cache().shuffle(<span class="hljs-number">1000</span>).prefetch(buffer_size=AUTOTUNE)<br>val_ds = val_ds.cache().prefetch(buffer_size=AUTOTUNE)<br><br><span class="hljs-comment"># 应用归一化到数据集</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">normalize_img</span>(<span class="hljs-params">image, label</span>):<br>    image = tf.cast(image, tf.float32) / <span class="hljs-number">255.0</span>  <span class="hljs-comment"># 将像素值归一化到 [0, 1]</span><br>    <span class="hljs-keyword">return</span> image, label<br><br>train_ds = train_ds.<span class="hljs-built_in">map</span>(normalize_img)<br>val_ds = val_ds.<span class="hljs-built_in">map</span>(normalize_img)<br><br><span class="hljs-comment"># 定义模型结构</span><br>model = Sequential([<br>    Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(<span class="hljs-number">96</span>, <span class="hljs-number">96</span>, <span class="hljs-number">3</span>)),<br>    MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)),<br>    Dropout(<span class="hljs-number">0.2</span>),<br><br>    Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>    MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)),<br>    Dropout(<span class="hljs-number">0.2</span>),<br><br>    Conv2D(<span class="hljs-number">128</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>    MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)),<br>    Dropout(<span class="hljs-number">0.2</span>),<br><br>    Flatten(),<br>    Dense(<span class="hljs-number">128</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>    Dropout(<span class="hljs-number">0.2</span>),<br>    Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)<br>])<br><br><span class="hljs-comment"># 编译模型，设置较小的学习率以提高数值稳定性</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=tf.keras.optimizers.Adam(learning_rate=<span class="hljs-number">1e-4</span>), <br>              loss=<span class="hljs-string">&#x27;sparse_categorical_crossentropy&#x27;</span>, <br>              metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><br><span class="hljs-comment"># 模型训练</span><br>epochs = <span class="hljs-number">10</span><br>history = model.fit(<br>    train_ds,<br>    epochs=epochs,<br>    validation_data=val_ds,<br>    verbose=<span class="hljs-number">1</span><br>)<br></code></pre></td></tr></table></figure><h4 id="batch-size影响，据我观察很小"><a href="#batch-size影响，据我观察很小" class="headerlink" title="batch_size影响，据我观察很小"></a>batch_size影响，据我观察很小</h4><p>为8时：<br><img src="/img/learn/2024-11-0221-17-47.png"><br>为16时：<br><img src="/img/learn/2024-11-0221-19-49.png"><br>为32时：<br><img src="/img/learn/2024-11-0221-22-25.png"><br><del>有一说一至少我看区别不大……</del></p><h3 id="次版"><a href="#次版" class="headerlink" title="次版"></a>次版</h3><p>后来esp-dl无法完成优化和量化部分，怀疑原因是</p><ul><li>输入数据集的形状不一样，是3通道的彩色图导致，在次版中改为1通道的灰度图</li><li>原文只采用了kaggle中10种手势的6种，而我初版使用了全部种类，这里也削减为前6种<br><strong>最后发现都不是</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras<br><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Conv2D, MaxPooling2D, Flatten, Dense, Dropout<br><span class="hljs-keyword">import</span> tf2onnx<br><br><span class="hljs-comment"># 数据集路径</span><br>data_dir = <span class="hljs-string">&quot;./leapGestRecog&quot;</span>  <span class="hljs-comment"># 新的根路径</span><br><br><span class="hljs-comment"># 设置图片的尺寸和批量大小</span><br>img_height, img_width = <span class="hljs-number">96</span>, <span class="hljs-number">96</span><br>batch_size = <span class="hljs-number">16</span><br><br><span class="hljs-comment"># 定义只处理前6个手势文件夹</span><br>allowed_folders = [<span class="hljs-string">&#x27;01_palm&#x27;</span>, <span class="hljs-string">&#x27;02_l&#x27;</span>, <span class="hljs-string">&#x27;03_fist&#x27;</span>, <span class="hljs-string">&#x27;04_fist_moved&#x27;</span>, <span class="hljs-string">&#x27;05_thumb&#x27;</span>, <span class="hljs-string">&#x27;06_index&#x27;</span>]<br><br><span class="hljs-comment"># 读取图像数据和标签</span><br>X = []<br>y = []<br>label_map = &#123;folder: idx <span class="hljs-keyword">for</span> idx, folder <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(allowed_folders)&#125;  <span class="hljs-comment"># 创建标签映射</span><br><br><span class="hljs-keyword">for</span> main_folder <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(os.listdir(data_dir)):<br>    main_folder_path = os.path.join(data_dir, main_folder)<br>    <span class="hljs-keyword">if</span> os.path.isdir(main_folder_path):<br>        <span class="hljs-keyword">for</span> folder_name <span class="hljs-keyword">in</span> allowed_folders:  <span class="hljs-comment"># 仅处理前6个手势文件夹</span><br>            folder_path = os.path.join(main_folder_path, folder_name)<br>            <span class="hljs-keyword">if</span> os.path.isdir(folder_path):<br>                label = label_map[folder_name]  <span class="hljs-comment"># 使用映射中的标签</span><br>                <span class="hljs-keyword">for</span> img_name <span class="hljs-keyword">in</span> os.listdir(folder_path):<br>                    img_path = os.path.join(folder_path, img_name)<br>                    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)<br>                    <span class="hljs-keyword">if</span> img <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                        img = cv2.resize(img, (img_width, img_height))<br>                        X.append(img)<br>                        y.append(label)<br><br><span class="hljs-comment"># 将数据转换为 NumPy 数组并规范化</span><br>X = np.array(X).reshape(-<span class="hljs-number">1</span>, img_height, img_width, <span class="hljs-number">1</span>) / <span class="hljs-number">255.0</span>  <span class="hljs-comment"># 归一化</span><br>y = np.array(y)<br><br><span class="hljs-comment"># 划分数据集</span><br>ts = <span class="hljs-number">0.3</span>  <span class="hljs-comment"># 测试集比例</span><br>X_train, X_test1, y_train, y_test1 = train_test_split(X, y, test_size=ts, random_state=<span class="hljs-number">42</span>)<br>X_test, X_cal, y_test, y_cal = train_test_split(X_test1, y_test1, test_size=ts, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 保存校准数据集为 pickle 文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;X_test.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    pickle.dump(X_test, file)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;y_test.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    pickle.dump(y_test, file)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;X_train.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    pickle.dump(X_train, file)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;y_train.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file: <br>    pickle.dump(y_train, file)<br><br><span class="hljs-comment"># 打印 TensorFlow 版本</span><br><span class="hljs-built_in">print</span>(tf.__version__)<br><br><span class="hljs-comment"># 定义模型结构</span><br>model = Sequential()<br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(<span class="hljs-number">96</span>, <span class="hljs-number">96</span>, <span class="hljs-number">1</span>))) <br>model.add(MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>model.add(Dropout(<span class="hljs-number">0.2</span>))<br>model.add(Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>)) <br>model.add(MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>model.add(Dropout(<span class="hljs-number">0.2</span>))<br>model.add(Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>model.add(Flatten())<br>model.add(Dense(<span class="hljs-number">128</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(Dense(<span class="hljs-number">6</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>))  <span class="hljs-comment"># 修改为6个分类</span><br><br><span class="hljs-comment"># 编译模型</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;sparse_categorical_crossentropy&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><br><span class="hljs-comment"># 训练模型</span><br>history = model.fit(X_train, y_train, epochs=<span class="hljs-number">5</span>, batch_size=<span class="hljs-number">64</span>, verbose=<span class="hljs-number">1</span>, validation_data=(X_test, y_test))<br><br><span class="hljs-comment"># 保存模型为 .h5 格式</span><br>model.save(<span class="hljs-string">&#x27;handrecognition_model.h5&#x27;</span>)<br><br><span class="hljs-comment"># 加载保存的模型</span><br>model = tf.keras.models.load_model(<span class="hljs-string">&quot;handrecognition_model.h5&quot;</span>)<br><br><span class="hljs-comment"># 将模型转换为 SavedModel 格式，准备转换为 ONNX</span><br>tf.saved_model.save(model, <span class="hljs-string">&quot;tmp_model&quot;</span>)<br><br><span class="hljs-comment"># 使用 tf2onnx 将 SavedModel 格式模型转换为 ONNX 格式</span><br>!python -m tf2onnx.convert --saved-model <span class="hljs-string">&quot;tmp_model&quot;</span> --output <span class="hljs-string">&quot;handrecognition_model.onnx&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="后续保存和转化模型"><a href="#后续保存和转化模型" class="headerlink" title="后续保存和转化模型"></a>后续保存和转化模型</h2><h3 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model.save(<span class="hljs-string">&#x27;handrecognition_model.h5&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="转化模型"><a href="#转化模型" class="headerlink" title="转化模型"></a>转化模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">model = tf.keras.models.load_model(<span class="hljs-string">&quot;handrecognition_model.h5&quot;</span>)<br>tf.saved_model.save(model, <span class="hljs-string">&quot;tmp_model&quot;</span>)<br><span class="hljs-keyword">import</span> tf2onnx<br>!python -m tf2onnx.convert --saved-model <span class="hljs-string">&quot;tmp_model&quot;</span> --output <span class="hljs-string">&quot;handrecognition_model.onnx&quot;</span><br></code></pre></td></tr></table></figure><h3 id="和google-colab结合（我还目前用不到，所以未尝试）"><a href="#和google-colab结合（我还目前用不到，所以未尝试）" class="headerlink" title="和google.colab结合（我还目前用不到，所以未尝试）"></a>和google.colab结合（我还目前用不到，所以未尝试）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Step 3: 压缩文件（可选）</span><br>!<span class="hljs-built_in">zip</span> -r handrecognition_model.<span class="hljs-built_in">zip</span> tmp_model<br></code></pre></td></tr></table></figure><h4 id="这是压缩成功的意思"><a href="#这是压缩成功的意思" class="headerlink" title="这是压缩成功的意思"></a>这是压缩成功的意思</h4><pre><code class="hljs">  adding: tmp_model/ (stored 0%)  adding: tmp_model/variables/ (stored 0%)  adding: tmp_model/variables/variables.data-00000-of-00001 (deflated 10%)  adding: tmp_model/variables/variables.index (deflated 64%)  adding: tmp_model/fingerprint.pb (stored 0%)  adding: tmp_model/assets/ (stored 0%)  adding: tmp_model/saved_model.pb (deflated 89%)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Step 4: 下载模型文件（适用于 Google Colab）</span><br><span class="hljs-keyword">from</span> google.colab <span class="hljs-keyword">import</span> files<br>files.download(<span class="hljs-string">&quot;handrecognition_model.h5&quot;</span>)<br>files.download(<span class="hljs-string">&quot;handrecognition_model.onnx&quot;</span>)<br>files.download(<span class="hljs-string">&quot;handrecognition_model.zip&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="netron可视化"><a href="#netron可视化" class="headerlink" title="netron可视化"></a>netron可视化</h2><p>初版模型可视化：<br><img src="/img/learn/2024-11-0517-51-13.png"><br>次版模型可视化：<br><img src="/img/learn/2024-11-0519-06-18.png"><br>原版模型可视化：<br><img src="/img/learn/2024-11-0517-55-04.png"></p>]]></content>
    
    
    <categories>
      
      <category>fyp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>building_with_espdl-1-failure</title>
    <link href="/2024/11/01/Ali/"/>
    <url>/2024/11/01/Ali/</url>
    
    <content type="html"><![CDATA[<h1 id="building-with-espdl-1-failure"><a href="#building-with-espdl-1-failure" class="headerlink" title="building_with_espdl-1-failure"></a>building_with_espdl-1-failure</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Conv2D, MaxPooling2D, Dense, Flatten, Dropout<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-built_in">print</span>(tf.__version__)          <span class="hljs-comment"># 打印 TensorFlow 版本</span><br><span class="hljs-built_in">print</span>(tf.keras.__file__)       <span class="hljs-comment"># 打印 Keras 的实际路径</span><br></code></pre></td></tr></table></figure><h1 id="这两行是上面打印版本和实际路径的输出结果"><a href="#这两行是上面打印版本和实际路径的输出结果" class="headerlink" title="这两行是上面打印版本和实际路径的输出结果"></a>这两行是上面打印版本和实际路径的输出结果</h1><pre><code class="hljs">2.17.0/home/dahao/anaconda3/envs/lowgensim/lib/python3.10/site-packages/keras/api/_tf_keras/keras/__init__.py</code></pre><h1 id="这一步pkl的作用尚且未知，不懂pkl的意义是什么"><a href="#这一步pkl的作用尚且未知，不懂pkl的意义是什么" class="headerlink" title="这一步pkl的作用尚且未知，不懂pkl的意义是什么"></a>这一步pkl的作用尚且未知，不懂pkl的意义是什么</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/dahao/code/Blogs/ESP-DL/model_development/X_test.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    X_test = pickle.load(file)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/dahao/code/Blogs/ESP-DL/model_development/y_test.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    y_test = pickle.load(file)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/dahao/code/Blogs/ESP-DL/model_development/X_train.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    X_train = pickle.load(file)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/dahao/code/Blogs/ESP-DL/model_development/y_train.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    y_train = pickle.load(file)<br></code></pre></td></tr></table></figure><h1 id="从数据集中选了其中一个文件夹中的其中一部分数据"><a href="#从数据集中选了其中一个文件夹中的其中一部分数据" class="headerlink" title="从数据集中选了其中一个文件夹中的其中一部分数据"></a>从数据集中选了其中一个文件夹中的其中一部分数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置数据集路径</span><br>data_dir = <span class="hljs-string">&quot;./leapgestrecog/leapGestRecog&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X = []<br>y = []<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment"># 读取每个手势类别文件夹中的图像文件</span><br><span class="hljs-keyword">for</span> gesture_folder <span class="hljs-keyword">in</span> os.listdir(data_dir):<br>    gesture_folder_path = os.path.join(data_dir, gesture_folder)<br>    <span class="hljs-keyword">if</span> os.path.isdir(gesture_folder_path):  <span class="hljs-comment"># 检查是否是文件夹</span><br>        <span class="hljs-keyword">for</span> gesture_instance <span class="hljs-keyword">in</span> os.listdir(gesture_folder_path):<br>            instance_dir = os.path.join(gesture_folder_path, gesture_instance)<br>            <span class="hljs-keyword">if</span> os.path.isdir(instance_dir):  <span class="hljs-comment"># 检查是否是文件夹</span><br>                <span class="hljs-keyword">for</span> image_file <span class="hljs-keyword">in</span> os.listdir(instance_dir):<br>                    image_path = os.path.join(instance_dir, image_file)<br>                    <span class="hljs-comment"># 读取图像并进行预处理</span><br>                    image = Image.<span class="hljs-built_in">open</span>(image_path).convert(<span class="hljs-string">&quot;L&quot;</span>)  <span class="hljs-comment"># 转为灰度图像</span><br>                    image = image.resize((<span class="hljs-number">96</span>, <span class="hljs-number">96</span>))  <span class="hljs-comment"># 调整图像大小</span><br>                    X.append(np.array(image))  <span class="hljs-comment"># 将图像添加到列表</span><br>                    y.append(gesture_instance)  <span class="hljs-comment"># 使用手势实例作为标签</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将列表转为 NumPy 数组</span><br>X = np.array(X)<br>y = np.array(y)<br><br></code></pre></td></tr></table></figure><h1 id="检验数据集形状和标签形状"><a href="#检验数据集形状和标签形状" class="headerlink" title="检验数据集形状和标签形状"></a>检验数据集形状和标签形状</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;数据集形状: <span class="hljs-subst">&#123;X.shape&#125;</span>, 标签形状: <span class="hljs-subst">&#123;y.shape&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">数据集形状: (20000, 96, 96), 标签形状: (20000,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br>ts = <span class="hljs-number">0.3</span> <span class="hljs-comment"># Percentage of images that we want to use for testing. </span><br>X_train, X_test1, y_train, y_test1 = train_test_split(X, y, test_size=ts, random_state=<span class="hljs-number">42</span>)<br>X_test, X_cal, y_test, y_cal = train_test_split(X_test1, y_test1, test_size=ts, random_state=<span class="hljs-number">42</span>)<br><br></code></pre></td></tr></table></figure><h1 id="cnn算法部分"><a href="#cnn算法部分" class="headerlink" title="cnn算法部分"></a>cnn算法部分</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(tf.__version__)<br><br>model = Sequential()<br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(<span class="hljs-number">96</span>, <span class="hljs-number">96</span>, <span class="hljs-number">1</span>))) <br>model.add(MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>model.add(Dropout(<span class="hljs-number">0.2</span>))<br>model.add(Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>)) <br>model.add(MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>model.add(Dropout(<span class="hljs-number">0.2</span>))<br>model.add(Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>model.add(Flatten())<br>model.add(Dense(<span class="hljs-number">128</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(Dense(<span class="hljs-number">6</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>))<br><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,loss=<span class="hljs-string">&#x27;sparse_categorical_crossentropy&#x27;</span>,metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><br>model.summary()<br></code></pre></td></tr></table></figure><h1 id="这部分是cnn算法的输出结果，和原作者的相吻合"><a href="#这部分是cnn算法的输出结果，和原作者的相吻合" class="headerlink" title="这部分是cnn算法的输出结果，和原作者的相吻合"></a>这部分是cnn算法的输出结果，和原作者的相吻合</h1><pre><code class="hljs">2.17.0</code></pre><pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><span style="font-weight: bold">Model: "sequential_8"</span></pre><pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace">┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓┃<span style="font-weight: bold"> Layer (type)                    </span>┃<span style="font-weight: bold"> Output Shape           </span>┃<span style="font-weight: bold">       Param # </span>┃┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩│ conv2d_24 (<span style="color: #0087ff; text-decoration-color: #0087ff">Conv2D</span>)              │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">92</span>, <span style="color: #00af00; text-decoration-color: #00af00">92</span>, <span style="color: #00af00; text-decoration-color: #00af00">32</span>)     │           <span style="color: #00af00; text-decoration-color: #00af00">832</span> │├─────────────────────────────────┼────────────────────────┼───────────────┤│ max_pooling2d_24 (<span style="color: #0087ff; text-decoration-color: #0087ff">MaxPooling2D</span>) │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">46</span>, <span style="color: #00af00; text-decoration-color: #00af00">46</span>, <span style="color: #00af00; text-decoration-color: #00af00">32</span>)     │             <span style="color: #00af00; text-decoration-color: #00af00">0</span> │├─────────────────────────────────┼────────────────────────┼───────────────┤│ dropout_16 (<span style="color: #0087ff; text-decoration-color: #0087ff">Dropout</span>)            │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">46</span>, <span style="color: #00af00; text-decoration-color: #00af00">46</span>, <span style="color: #00af00; text-decoration-color: #00af00">32</span>)     │             <span style="color: #00af00; text-decoration-color: #00af00">0</span> │├─────────────────────────────────┼────────────────────────┼───────────────┤│ conv2d_25 (<span style="color: #0087ff; text-decoration-color: #0087ff">Conv2D</span>)              │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">44</span>, <span style="color: #00af00; text-decoration-color: #00af00">44</span>, <span style="color: #00af00; text-decoration-color: #00af00">64</span>)     │        <span style="color: #00af00; text-decoration-color: #00af00">18,496</span> │├─────────────────────────────────┼────────────────────────┼───────────────┤│ max_pooling2d_25 (<span style="color: #0087ff; text-decoration-color: #0087ff">MaxPooling2D</span>) │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">22</span>, <span style="color: #00af00; text-decoration-color: #00af00">22</span>, <span style="color: #00af00; text-decoration-color: #00af00">64</span>)     │             <span style="color: #00af00; text-decoration-color: #00af00">0</span> │├─────────────────────────────────┼────────────────────────┼───────────────┤│ dropout_17 (<span style="color: #0087ff; text-decoration-color: #0087ff">Dropout</span>)            │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">22</span>, <span style="color: #00af00; text-decoration-color: #00af00">22</span>, <span style="color: #00af00; text-decoration-color: #00af00">64</span>)     │             <span style="color: #00af00; text-decoration-color: #00af00">0</span> │├─────────────────────────────────┼────────────────────────┼───────────────┤│ conv2d_26 (<span style="color: #0087ff; text-decoration-color: #0087ff">Conv2D</span>)              │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">20</span>, <span style="color: #00af00; text-decoration-color: #00af00">20</span>, <span style="color: #00af00; text-decoration-color: #00af00">64</span>)     │        <span style="color: #00af00; text-decoration-color: #00af00">36,928</span> │├─────────────────────────────────┼────────────────────────┼───────────────┤│ max_pooling2d_26 (<span style="color: #0087ff; text-decoration-color: #0087ff">MaxPooling2D</span>) │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">10</span>, <span style="color: #00af00; text-decoration-color: #00af00">10</span>, <span style="color: #00af00; text-decoration-color: #00af00">64</span>)     │             <span style="color: #00af00; text-decoration-color: #00af00">0</span> │├─────────────────────────────────┼────────────────────────┼───────────────┤│ flatten_8 (<span style="color: #0087ff; text-decoration-color: #0087ff">Flatten</span>)             │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">6400</span>)           │             <span style="color: #00af00; text-decoration-color: #00af00">0</span> │├─────────────────────────────────┼────────────────────────┼───────────────┤│ dense_16 (<span style="color: #0087ff; text-decoration-color: #0087ff">Dense</span>)                │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">128</span>)            │       <span style="color: #00af00; text-decoration-color: #00af00">819,328</span> │├─────────────────────────────────┼────────────────────────┼───────────────┤│ dense_17 (<span style="color: #0087ff; text-decoration-color: #0087ff">Dense</span>)                │ (<span style="color: #00d7ff; text-decoration-color: #00d7ff">None</span>, <span style="color: #00af00; text-decoration-color: #00af00">6</span>)              │           <span style="color: #00af00; text-decoration-color: #00af00">774</span> │└─────────────────────────────────┴────────────────────────┴───────────────┘</pre><pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><span style="font-weight: bold"> Total params: </span><span style="color: #00af00; text-decoration-color: #00af00">876,358</span> (3.34 MB)</pre><pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><span style="font-weight: bold"> Trainable params: </span><span style="color: #00af00; text-decoration-color: #00af00">876,358</span> (3.34 MB)</pre><pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><span style="font-weight: bold"> Non-trainable params: </span><span style="color: #00af00; text-decoration-color: #00af00">0</span> (0.00 B)</pre><h1 id="尝试解决部分，未成功"><a href="#尝试解决部分，未成功" class="headerlink" title="尝试解决部分，未成功"></a>尝试解决部分，未成功</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加通道维度</span><br>X_train = X_train.reshape(X_train.shape[<span class="hljs-number">0</span>], <span class="hljs-number">96</span>, <span class="hljs-number">96</span>, <span class="hljs-number">1</span>)<br>X_test = X_test.reshape(X_test.shape[<span class="hljs-number">0</span>], <span class="hljs-number">96</span>, <span class="hljs-number">96</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 确保数据类型为float32</span><br>X_train = X_train.astype(<span class="hljs-string">&#x27;float32&#x27;</span>) / <span class="hljs-number">255.0</span><br>X_test = X_test.astype(<span class="hljs-string">&#x27;float32&#x27;</span>) / <span class="hljs-number">255.0</span><br><br><span class="hljs-comment"># 对标签进行编码</span><br><span class="hljs-keyword">from</span> keras.utils <span class="hljs-keyword">import</span> to_categorical<br>y_train = to_categorical(y_train)<br>y_test = to_categorical(y_test)<br><br><span class="hljs-comment"># 训练模型</span><br>history = model.fit(X_train, y_train, epochs=<span class="hljs-number">5</span>, batch_size=<span class="hljs-number">64</span>, verbose=<span class="hljs-number">1</span>, validation_data=(X_test, y_test))<br></code></pre></td></tr></table></figure><h2 id="一直显示这部分报错结果"><a href="#一直显示这部分报错结果" class="headerlink" title="一直显示这部分报错结果"></a>一直显示这部分报错结果</h2><pre><code class="hljs">---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)Cell In[272], line 11      9 # 对标签进行编码     10 from keras.utils import to_categorical---&gt; 11 y_train = to_categorical(y_train)     12 y_test = to_categorical(y_test)     14 # 训练模型File ~/anaconda3/envs/lowgensim/lib/python3.10/site-packages/keras/src/utils/numerical_utils.py:86, in to_categorical(x, num_classes)     84         x = backend.numpy.reshape(x, newshape)     85     return backend.nn.one_hot(x, num_classes)---&gt; 86 x = np.array(x, dtype=&quot;int64&quot;)     87 input_shape = x.shape     89 # Shrink the last dimension if the shape is (..., 1).ValueError: invalid literal for int() with base 10: &#39;01_palm&#39;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">type</span>(y_train)<br></code></pre></td></tr></table></figure><pre><code class="hljs">numpy.ndarray</code></pre><h1 id="今日有效学习链接："><a href="#今日有效学习链接：" class="headerlink" title="今日有效学习链接："></a>今日有效学习链接：</h1><p>1、本文基于并且想尝试复现的github文档：<br><a href="https://github.com/alibukharai/Blogs/blob/main/ESP-DL/building_with_espdl.md">https://github.com/alibukharai/Blogs/blob/main/ESP-DL/building_with_espdl.md</a><br>2、No module named ‘tensorflow.keras‘报错信息的解决方法：<br><a href="https://blog.csdn.net/Zinnir/article/details/125999939?fromshare=blogdetail&sharetype=blogdetail&sharerId=125999939&sharerefer=PC&sharesource=m0_60571820&sharefrom=from_link">https://blog.csdn.net/Zinnir/article/details/125999939?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=125999939&amp;sharerefer=PC&amp;sharesource=m0_60571820&amp;sharefrom=from_link</a><br>我没有用python，我用的是shell，原理相同<br>3、kaggle怎么下载数据集？<br><a href="https://blog.csdn.net/weixin_73577120/article/details/143170847?fromshare=blogdetail&sharetype=blogdetail&sharerId=143170847&sharerefer=PC&sharesource=m0_60571820&sharefrom=from_link">https://blog.csdn.net/weixin_73577120/article/details/143170847?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=143170847&amp;sharerefer=PC&amp;sharesource=m0_60571820&amp;sharefrom=from_link</a></p><p>原来失恋是这种感觉，也有可能我本来就从未得到过吧……一直是我在自我幻想罢了，无所谓，短时间我不会再相信爱情了……<br>人，总是要向前看的，找不到答案的话就找自己吧！</p>]]></content>
    
    
    <categories>
      
      <category>fyp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Working with Your Own Data and Documents in Python</title>
    <link href="/2024/10/24/AI%20Python%20for%20Beginners%EF%BC%9AWorking%20with%20Your%20Own%20Data%20and%20Documents%20in%20Python/"/>
    <url>/2024/10/24/AI%20Python%20for%20Beginners%EF%BC%9AWorking%20with%20Your%20Own%20Data%20and%20Documents%20in%20Python/</url>
    
    <content type="html"><![CDATA[<h1 id="Working-with-Your-Own-Data-and-Documents-in-Python"><a href="#Working-with-Your-Own-Data-and-Documents-in-Python" class="headerlink" title="Working with Your Own Data and Documents in Python"></a>Working with Your Own Data and Documents in Python</h1><h2 id="Using-files-in-Python"><a href="#Using-files-in-Python" class="headerlink" title="Using files in Python"></a>Using files in Python</h2><p><strong>open()</strong> 函数是 Python 内置的用于打开文件并返回一个文件对象的函数。<br><code>file_object = open(file_name, mode)</code></p><h3 id="mode-打开文件的模式："><a href="#mode-打开文件的模式：" class="headerlink" title="mode: 打开文件的模式："></a>mode: 打开文件的模式：</h3><ul><li>**’r’**：读取模式（默认）。</li><li>**’w’**：写入模式，会覆盖原有文件内容。</li><li>**’a’**：追加模式，在文件末尾追加内容。</li><li>**’x’**：创建新文件，如果文件已存在则报错。</li><li>**’b’**：以二进制模式打开。</li><li>**’+’**：可读写模式。</li></ul><h3 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h3><ul><li><strong>read()</strong>: 读取文件内容。</li><li><strong>readline()</strong>: 读取一行内容。</li><li><strong>readlines()</strong>: 读取所有行并返回一个列表。</li><li><strong>write()</strong>: 写入内容。</li><li><strong>close()</strong>: 关闭文件。</li><li><strong>seek()</strong>: 移动文件指针。</li><li><strong>tell()</strong>: 返回文件指针的当前位置。-</li></ul><h2 id="Reading-journals-from-food-critics"><a href="#Reading-journals-from-food-critics" class="headerlink" title="Reading journals from food critics"></a>Reading journals from food critics</h2><h3 id="split"><a href="#split" class="headerlink" title=".split()"></a>.split()</h3><p> 在 Python 中，<code>.split()</code> 是一个字符串方法，它的作用是将一个字符串按照指定的分隔符拆分成一个列表。<br> <code>字符串.split(分隔符, maxsplit)</code></p><ul><li><strong>字符串:</strong> 你要进行分割的字符串。</li><li><strong>分隔符:</strong> 用来分割字符串的字符或子字符串。如果不指定分隔符，则默认以空格为分隔符。</li><li><strong>maxsplit:</strong> 可选参数，指定最多分割的次数。如果不指定，则默认分割所有可能的子字符串。<br>例如：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"># 按特定字符分割 filename = <span class="hljs-string">&quot;data.txt&quot;</span> <span class="hljs-keyword">extension</span> = filename.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>] <span class="hljs-built_in">print</span>(<span class="hljs-keyword">extension</span>) # 输出：txt<br></code></pre></td></tr></table></figure>可以实现切割扩展名的作用。</li></ul><h2 id="Vacation-planning-using-CSV-files"><a href="#Vacation-planning-using-CSV-files" class="headerlink" title="Vacation planning using CSV files"></a>Vacation planning using CSV files</h2><p><strong><code>csv.DictReader</code></strong>: 这是一个 Python 的 CSV 模块中的类，用于读取 CSV 文件，并将其中的每一行数据作为字典返回。字典的键就是 CSV 文件的第一行（即表头），值就是对应行的值。</p><h2 id="Turning-code-blocks-into-reusable-functions"><a href="#Turning-code-blocks-into-reusable-functions" class="headerlink" title="Turning code blocks into reusable functions"></a>Turning code blocks into reusable functions</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>(<span class="hljs-params">参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>, ...</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;函数的文档字符串（可选）&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 函数体</span><br>    <span class="hljs-keyword">return</span> 返回值  <span class="hljs-comment"># 可选，如果没有 return 语句，则默认返回 None</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Extending Python with Packages and APIs</title>
    <link href="/2024/10/24/AI%20Python%20for%20Beginners%EF%BC%9AExtending%20Python%20with%20Packages%20and%20APIs/"/>
    <url>/2024/10/24/AI%20Python%20for%20Beginners%EF%BC%9AExtending%20Python%20with%20Packages%20and%20APIs/</url>
    
    <content type="html"><![CDATA[<h1 id="Extending-Python-with-Packages-and-APIs"><a href="#Extending-Python-with-Packages-and-APIs" class="headerlink" title="Extending Python with Packages and APIs"></a>Extending Python with Packages and APIs</h1><h2 id="Using-functions-from-a-local-file"><a href="#Using-functions-from-a-local-file" class="headerlink" title="Using functions from a local file"></a>Using functions from a local file</h2><p>导入函数的方式：<br>1、将整个模块导入，然后通过模块名加点号的方式来访问其中的函数。也可以在第一行末尾加as，用别名。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">import <span class="hljs-built_in">math</span><br><br>result = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">16</span>)  # 调用<span class="hljs-built_in">math</span>模块中的<span class="hljs-built_in">sqrt</span>函数<br><span class="hljs-built_in">print</span>(result)  # 输出 <span class="hljs-number">4.0</span><br></code></pre></td></tr></table></figure><p>2、只导入需要的特定函数。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">math</span> <span class="hljs-variable">import</span> <span class="hljs-variable">sqrt</span><br><br><span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-function"><span class="hljs-title">sqrt</span>(<span class="hljs-number">16</span>)</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable"><span class="hljs-class">result</span></span>)</span><br></code></pre></td></tr></table></figure><p>3、导入模块中的所有函数和变量。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">math</span> <span class="hljs-variable">import</span> *<br><br><span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-function"><span class="hljs-title">sqrt</span>(<span class="hljs-number">16</span>)</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable"><span class="hljs-class">result</span></span>)</span><br></code></pre></td></tr></table></figure><h2 id="Built-in-packages"><a href="#Built-in-packages" class="headerlink" title="Built-in packages"></a>Built-in packages</h2><ul><li><strong>module模块</strong> 是最小的代码单元。</li><li><strong>package包</strong> 是多个模块的集合，用于组织代码。</li><li><strong>library库</strong> 是一个更广泛的概念，可以指单个模块、多个模块或一个包，通常提供特定的功能。</li></ul><h3 id="math-库"><a href="#math-库" class="headerlink" title="math 库"></a>math 库</h3><ul><li><strong>主要功能：</strong> 提供了大量的数学函数，用于进行基本的数学运算。</li><li><strong>常用函数：</strong><ul><li><code>sqrt(x)</code>：计算 x 的平方根。</li><li><code>pow(x, y)</code>：计算 x 的 y 次方。</li><li><code>sin(x)</code>、<code>cos(x)</code>、<code>tan(x)</code>：三角函数。</li><li><code>exp(x)</code>：计算 e 的 x 次方。</li><li><code>log(x)</code>、<code>log10(x)</code>：自然对数和以 10 为底的对数。</li><li><code>ceil(x)</code>：向上取整。</li><li><code>floor(x)</code>：向下取整。</li><li><code>radians(degrees)</code>：将角度转换为弧度。</li><li><code>degrees(radians)</code>：将弧度转换为角度。</li></ul></li></ul><h3 id="statistics-库"><a href="#statistics-库" class="headerlink" title="statistics 库"></a>statistics 库</h3><ul><li><strong>主要功能：</strong> 提供了计算各种统计数据的函数。</li><li><strong>常用函数：</strong><ul><li><code>mean(data)</code>：计算数据的平均值。</li><li><code>median(data)</code>：计算数据的中位数。</li><li><code>mode(data)</code>：计算数据的众数。</li><li><code>variance(data)</code>：计算数据的方差。</li><li><code>stdev(data)</code>：计算数据的标准差。</li><li><code>pvariance(data)</code>：计算总体方差。</li><li><code>pstdev(data)</code>：计算总体标准差。</li></ul></li></ul><h3 id="random-库"><a href="#random-库" class="headerlink" title="random 库"></a>random 库</h3><ul><li><strong>主要功能：</strong> 用于生成各种随机数。</li><li><strong>常用函数：</strong><ul><li><code>random()</code>：生成 [0.0, 1.0) 之间的随机浮点数。</li><li><code>randint(a, b)</code>：生成 [a, b] 之间的随机整数。</li><li><code>uniform(a, b)</code>：生成 [a, b) 之间的随机浮点数。</li><li><code>choice(seq)</code>：从序列 seq 中随机选择一个元素。</li><li><code>shuffle(x)</code>：将序列 x 中的元素随机打乱。</li><li><code>sample(population, k)</code>：从 population 序列中随机抽取 k 个元素，组成一个新列表。</li></ul></li></ul><h2 id="Using-third-party-packages"><a href="#Using-third-party-packages" class="headerlink" title="Using third-party packages"></a>Using third-party packages</h2><h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><ul><li><strong>主要功能：</strong> pandas 是 Python 中强大的数据分析和操作工具，特别擅长处理表格型数据。</li><li><strong>常用功能：</strong><ul><li><strong>Series:</strong> 一维带标签数组，类似于 Excel 中的一列。</li><li><strong>DataFrame:</strong> 二维带标签表格，类似于 Excel 工作表。</li><li><strong>读取数据：</strong> 从各种数据源（如 CSV、Excel、SQL 数据库）读取数据。</li><li><strong>数据清洗：</strong> 处理缺失值、重复值、异常值。</li><li><strong>数据转换：</strong> 数据类型转换、重塑、合并、分组。</li><li><strong>数据分析：</strong> 计算统计量、排序、筛选、分组聚合。</li></ul></li><li><strong>常用函数：</strong><ul><li><code>read_csv()</code>, <code>read_excel()</code>: 读取 CSV 和 Excel 文件。</li><li><code>head()</code>, <code>tail()</code>: 查看数据的前几行或后几行。</li><li><code>describe()</code>: 计算数据的基本统计量。</li><li><code>groupby()</code>: 按一列或多列分组。</li><li><code>merge()</code>: 合并 DataFrame。</li><li><code>pivot_table()</code>: 创建透视表。</li></ul></li></ul><h3 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h3><ul><li><strong>主要功能：</strong> 提供了高性能的多维数组对象和对这些数组进行操作的工具。</li><li><strong>常用功能：</strong><ul><li><strong>ndarray：</strong> 多维数组对象，是 NumPy 的核心数据结构。</li><li><strong>数组创建：</strong> 创建各种类型的数组，如随机数组、全零数组、全一数组等。</li><li><strong>数组运算：</strong> 支持向量化运算，大大提高计算效率。</li><li><strong>线性代数：</strong> 提供线性代数运算，如矩阵乘法、求逆等。</li><li><strong>随机数生成：</strong> 生成各种随机数。</li></ul></li><li><strong>常用函数：</strong><ul><li><code>array()</code>: 创建数组。</li><li><code>arange()</code>: 创建等差数组。</li><li><code>linspace()</code>: 创建等间隔数组。</li><li><code>reshape()</code>: 改变数组形状。</li><li><code>dot()</code>: 计算矩阵乘积。</li><li><code>random.rand()</code>, <code>random.randn()</code>: 生成随机数。</li></ul></li></ul><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><ul><li><strong>主要功能：</strong> Matplotlib 是 Python 的绘图库，用于创建高质量的静态、动态和交互式图表。</li><li><strong>常用功能：</strong><ul><li><strong>线图：</strong> 绘制折线图。</li><li><strong>散点图：</strong> 绘制散点图。</li><li><strong>直方图：</strong> 绘制直方图。</li><li><strong>饼图：</strong> 绘制饼图。</li><li><strong>箱线图：</strong> 绘制箱线图。</li><li><strong>子图：</strong> 在一个画布上绘制多个子图。</li><li><strong>自定义：</strong> 对图表进行自定义设置，如标题、标签、颜色等。</li></ul></li><li><strong>常用函数：</strong><ul><li><code>plot()</code>: 绘制线图。</li><li><code>scatter()</code>: 绘制散点图。</li><li><code>hist()</code>: 绘制直方图。</li><li><code>pie()</code>: 绘制饼图。</li><li><code>boxplot()</code>: 绘制箱线图。</li><li><code>subplot()</code>: 创建子图。</li></ul></li></ul><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><p>答：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br># Assuming <span class="hljs-string">&#x27;df&#x27;</span> <span class="hljs-keyword">is</span> your DataFrame containing the data<br><br># <span class="hljs-keyword">Filter</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">where</span> <span class="hljs-string">&#x27;Model&#x27;</span> contains <span class="hljs-string">&#x27;Accord&#x27;</span><br>filtered_df = df[df[<span class="hljs-string">&#x27;Model&#x27;</span>].str.contains(<span class="hljs-string">&#x27;Accord&#x27;</span>, <span class="hljs-keyword">case</span>=<span class="hljs-keyword">False</span>)]<br><br># Display the filtered <span class="hljs-keyword">table</span><br>print(filtered_df)<br><br></code></pre></td></tr></table></figure><p><code>df[]</code> 不是函数，它是 pandas DataFrame 的索引运算符（indexing operator），是一种特殊的语法。</p><ul><li><code>df[&#39;Model&#39;]</code> 选择数据表中的’Model’列</li><li><code>.str.contains(&#39;Accord&#39;, case=False)</code><ul><li>检查每一行的Model列是否包含’Accord’这个词</li><li><code>case=False</code> 表示不区分大小写，比如’accord’、’ACCORD’都会被匹配到</li><li>这会返回一个布尔值序列（True&#x2F;False）</li></ul></li><li><code>df[...]</code> 使用这个布尔序列来筛选原始数据表，只保留结果为True的行。</li></ul><h2 id="APIs-to-get-data-from-the-web"><a href="#APIs-to-get-data-from-the-web" class="headerlink" title="APIs to get data from the web"></a>APIs to get data from the web</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs prolog"># 假设data是这样的<span class="hljs-symbol">JSON</span>结构：<br>data = &#123;<br>    <span class="hljs-string">&#x27;list&#x27;</span>: [                     # list是一个列表<br>        &#123;                         # [<span class="hljs-number">0</span>]表示取第一个元素（第一个字典）<br>            <span class="hljs-string">&#x27;main&#x27;</span>: &#123;             <br>                <span class="hljs-string">&#x27;temp&#x27;</span>: <span class="hljs-number">20.5</span>      # 温度数据<br>            &#125;,<br>            <span class="hljs-string">&#x27;weather&#x27;</span>: [          # weather也是一个列表<br>                &#123;                 # [<span class="hljs-number">0</span>]表示取第一个天气描述<br>                    <span class="hljs-string">&#x27;description&#x27;</span>: <span class="hljs-string">&#x27;晴天&#x27;</span><br>                &#125;<br>            ],<br>            <span class="hljs-string">&#x27;wind&#x27;</span>: &#123;<br>                <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-number">5.2</span>      # 风速数据<br>            &#125;<br>        &#125;,<br>        &#123;                        # 这是列表的第二个元素[<span class="hljs-number">1</span>]<br>            # 更多天气数据...<br>        &#125;<br>    ]<br>&#125;<br><br># 所以代码是这样工作的：<br>temperature = data[<span class="hljs-string">&#x27;list&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;main&#x27;</span>][<span class="hljs-string">&#x27;temp&#x27;</span>]        # 获取<span class="hljs-number">20.5</span><br>description = data[<span class="hljs-string">&#x27;list&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;weather&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;description&#x27;</span>]  # 获取<span class="hljs-string">&#x27;晴天&#x27;</span><br>wind_speed = data[<span class="hljs-string">&#x27;list&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;wind&#x27;</span>][<span class="hljs-string">&#x27;speed&#x27;</span>]        # 获取<span class="hljs-number">5.2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Basics of AI Python Coding</title>
    <link href="/2024/10/23/AI%20Python%20for%20Beginners%EF%BC%9ABasics%20of%20AI%20Python%20Coding/"/>
    <url>/2024/10/23/AI%20Python%20for%20Beginners%EF%BC%9ABasics%20of%20AI%20Python%20Coding/</url>
    
    <content type="html"><![CDATA[<h1 id="Basics-of-AI-Python-Coding"><a href="#Basics-of-AI-Python-Coding" class="headerlink" title="Basics of AI Python Coding"></a>Basics of AI Python Coding</h1><h2 id="Navigating-the-learning-platform"><a href="#Navigating-the-learning-platform" class="headerlink" title="Navigating the learning platform"></a>Navigating the learning platform</h2><p>jupyter L2_student通过shift+enter运行代码</p><h2 id="Running-your-first-program"><a href="#Running-your-first-program" class="headerlink" title="Running your first program"></a>Running your first program</h2><p>#+空格表示注释</p><h2 id="Data-in-Python"><a href="#Data-in-Python" class="headerlink" title="Data in Python"></a>Data in Python</h2><h3 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h3><p>图像和声音都是以文本或数字形式处理的<br>“字符串”<br>“””<br>多行字符串<br>“””</p><h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p>int 整数 float 浮点数<br>a ** b a的b次方</p><h2 id="Combining-text-and-calculations"><a href="#Combining-text-and-calculations" class="headerlink" title="Combining text and calculations"></a>Combining text and calculations</h2><h3 id="f-strings-格式化字符串"><a href="#f-strings-格式化字符串" class="headerlink" title="f-strings 格式化字符串"></a>f-strings 格式化字符串</h3><p>print(f”{:.0f}”)<br>f-strings 也可以作为被赋的值</p><h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><p>变量名不能包含空格<br><strong>Python 变量命名规则总结：</strong></p><ul><li>变量名只能包含字母、数字和下划线（_）。</li><li>变量名必须以字母或下划线开头。</li><li>变量名区分大小写（例如，age 和 Age 是不同的变量）。</li></ul><h2 id="Functions-Actions-on-Data"><a href="#Functions-Actions-on-Data" class="headerlink" title="Functions: Actions on Data"></a>Functions: Actions on Data</h2><p>向函数提供参数<br>len() 计算字符串长度或列表中元素个数（长度）<br>round(number) 四舍五入数</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Automating Tasks with Python</title>
    <link href="/2024/10/23/AI%20Python%20for%20Beginners%EF%BC%9AAutomating%20Tasks%20with%20Python/"/>
    <url>/2024/10/23/AI%20Python%20for%20Beginners%EF%BC%9AAutomating%20Tasks%20with%20Python/</url>
    
    <content type="html"><![CDATA[<h1 id="Automating-Tasks-with-Python"><a href="#Automating-Tasks-with-Python" class="headerlink" title="Automating Tasks with Python"></a>Automating Tasks with Python</h1><h2 id="Completing-a-task-list-with-AI"><a href="#Completing-a-task-list-with-AI" class="headerlink" title="Completing a task list with AI"></a>Completing a task list with AI</h2><p>列表变量list_name &#x3D;  [a, b, c]，从0开始计数，通过list_name[n]来访问对应的单个元素。<br>list.append() 增加元素到末尾 list.remove()删除元素。<br>初始化list_name &#x3D; []</p><h2 id="Repeating-tasks-with-for-loops"><a href="#Repeating-tasks-with-for-loops" class="headerlink" title="Repeating tasks with for loops"></a>Repeating tasks with for loops</h2><p>Python依靠缩进来表示代码块的层级关系，而不像其他语言使用 <code>&#123;&#125;</code> 来包裹代码块。因此，在Python中<strong>缩进</strong>是语法的一部分，不能随意省略。通常使用4个空格作为标准缩进（而不是Tab键），这是为了代码风格的一致性。<br>在Python中，每一层嵌套代码块都需要<strong>缩进4个空格</strong>。<br>for 变量 in 可迭代对象:<br>    循环体代码</p><ul><li>**<code>变量</code>**：循环中的迭代变量，每次循环会自动被赋予当前元素的值。</li><li>**<code>可迭代对象</code>**：可以是列表、元组、字符串、字典、集合，甚至使用 <code>range()</code> 函数生成的数列。</li><li><strong>循环体代码</strong>：每次循环时要执行的代码，必须缩进（通常 4 个空格）。</li></ul><h2 id="Prioritizing-tasks-with-dictionaries-and-AI"><a href="#Prioritizing-tasks-with-dictionaries-and-AI" class="headerlink" title="Prioritizing tasks with dictionaries and AI"></a>Prioritizing tasks with dictionaries and AI</h2><h3 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h3><p>my_dict &#x3D; {‘name’: ‘Alice’, ‘age’: 30, ‘city’: ‘Beijing’}定义时用大括号，访问时用方括号，访问key时不加双引号。<br>字典中的键必须是唯一的，且通常是不可变数据类型（如字符串、数字或元组），而值可以是任意数据类型。<br><code>.keys()</code>可以查看键，<code>.values()</code>可以查看值，都不需要参数。</p><h2 id="Customizing-recipes-with-lists-dictionaries-and-AI"><a href="#Customizing-recipes-with-lists-dictionaries-and-AI" class="headerlink" title="Customizing recipes with lists, dictionaries and AI"></a>Customizing recipes with lists, dictionaries and AI</h2><p><strong>bool</strong> 在 Python 中是一种表示真假值的<strong>布尔型</strong>数据类型。它只有两个值：</p><ul><li><strong>True</strong>：表示真</li><li><strong>False</strong>：表示假</li></ul><h2 id="Comparing-data-in-Python"><a href="#Comparing-data-in-Python" class="headerlink" title="Comparing data in Python"></a>Comparing data in Python</h2><p>python中两个数比大小输出的值是一个bool<br>逻辑运算符 and or</p><h2 id="Helping-AI-make-decisions"><a href="#Helping-AI-make-decisions" class="headerlink" title="Helping AI make decisions"></a>Helping AI make decisions</h2><p>if 条件表达式:<br>    # 条件为真时执行的代码块<br>else:<br>    # 条件为假时执行的代码块</p><ul><li><strong>代码块：</strong> 条件为真时执行的代码，需要缩进。</li><li><strong>else：</strong> 可选的，当条件为假时执行的代码块，也需要缩进。<br>在 <strong>Python 的 f-string</strong> 中，<code>&#123;&#125;</code> 内的内容会被解析为 <strong>Python 表达式</strong>。由于 <strong>f-string</strong> 直接解释表达式，所以不允许在 <code>&#123;&#125;</code> 中使用反斜杠 <code>\</code> 来转义字符。方案就是内层用单引号，外层用双引号或者反之，总之不能重复。</li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Command-line Environment</title>
    <link href="/2024/10/22/Command-line%20Environment/"/>
    <url>/2024/10/22/Command-line%20Environment/</url>
    
    <content type="html"><![CDATA[<h1 id="Command-line-Environment"><a href="#Command-line-Environment" class="headerlink" title="Command-line Environment"></a>Command-line Environment</h1><h2 id="常用信号"><a href="#常用信号" class="headerlink" title="常用信号"></a>常用信号</h2><ul><li><strong>SIGTERM:</strong> 终止信号，通常用于请求进程正常退出。</li><li><strong>SIGINT:</strong> 中断信号，通常由用户按下Ctrl+C产生，用于中断正在运行的进程。</li><li><strong>SIGKILL:</strong> 杀死信号，强制终止进程，<strong>无法被进程捕获或忽略。</strong></li><li><strong>SIGSTOP:</strong> 停止信号，暂停进程的执行。</li><li><strong>SIGCONT:</strong> 继续信号，继续被暂停的进程。</li><li><strong>SIGALRM:</strong> 闹钟信号，用于实现定时器功能。</li><li><strong>SIGCHLD:</strong> 子进程状态改变信号，当子进程终止或停止时，父进程会收到该信号。</li><li><strong>SIGUSR1，SIGUSR2:</strong> 用户自定义信号，可以用来实现进程之间的通信。</li><li><strong>Ctrl+C (SIGINT):</strong> 这是最常用的信号，当你在终端中运行一个程序时，按下Ctrl+C，就会向该程序发送SIGINT信号，通常会终止程序的运行。</li><li><strong>Ctrl+Z (SIGTSTP):</strong> 这个信号会将当前的前台进程挂起，你可以使用命令<code>fg</code>将挂起的进程恢复到前台，或者使用<code>bg</code>将挂起的进程放到后台运行。</li><li><strong>Ctrl+\ (SIGQUIT):</strong> 这个信号除了终止程序外，还会生成一个core dump文件，这个文件可以用来调试程序。</li></ul><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>用于在终端窗口关闭后继续运行命令。<br><code>nohup command &amp;</code></p><ul><li><code>nohup</code>: 告诉系统在终端窗口关闭后继续运行命令。</li><li><code>command</code>: 要执行的命令。</li><li><code>&amp;</code>: 将命令放到后台运行。</li></ul><h2 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h2><ul><li><strong>-l 或 –list：</strong> 以长格式显示作业信息，包括作业编号、进程 ID、命令行等。</li><li><strong>-p 或 –pids：</strong> 只显示作业的进程 ID。</li><li><strong>-r 或 –running：</strong> 只显示正在运行的作业。</li><li><strong>-s 或 –stopped：</strong> 只显示已停止的作业。<br>可以使用百分号 + 任务编号（<code>jobs</code> 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</li></ul><h3 id="与-jobs-命令配合使用的命令"><a href="#与-jobs-命令配合使用的命令" class="headerlink" title="与 jobs 命令配合使用的命令"></a>与 jobs 命令配合使用的命令</h3><ul><li><strong>fg：</strong> 将后台作业调回前台继续运行。</li><li><strong>bg：</strong> 将一个停止的作业放到后台继续运行。</li><li><code>kill [signal] jobspec</code>：其中signal如果不指定，默认发送 <code>SIGTERM</code>。<code>-l</code>可以查看可发送的信号列表。</li></ul><h2 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h2><ul><li><strong>-a:</strong> 显示进程的命令行。</li><li><strong>-f:</strong> 根据完整的命令行进行匹配。</li><li><strong>-l:</strong> 显示进程名。</li><li><strong>-u:</strong> 根据用户 ID 匹配。</li><li><strong>-g:</strong> 根据进程组 ID 匹配。</li><li><strong>-P:</strong> 根据父进程 ID 匹配。</li><li><strong>-t:</strong> 根据终端名匹配。</li><li><strong>-x:</strong> 精确匹配进程名。</li><li><strong>-i:</strong> 忽略大小写。</li><li><strong>-v:</strong> 反向匹配，即查找不匹配的进程。</li></ul><h2 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h2><p>用于将后台运行的作业从当前 shell 的作业列表中删除。这意味着，即使你关闭了终端窗口，这些作业仍然会继续运行。<br><code>disown [-r] jobspec</code></p><ul><li><strong>jobspec</strong>：指定要删除的作业。可以使用作业号（如 <code>%1</code>）、作业名（如 <code>myjob</code>）或进程 ID（PID）。</li><li><strong>-r</strong>：删除所有后台作业。</li></ul><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><h3 id="tmux-的核心概念"><a href="#tmux-的核心概念" class="headerlink" title="tmux 的核心概念"></a>tmux 的核心概念</h3><ul><li><strong>会话 (session)：</strong> 一个独立的工作环境，可以包含多个窗口。</li><li><strong>窗口 (window)：</strong> 会话中的一个视图，可以包含多个窗格。</li><li><strong>窗格 (pane)：</strong> 窗口中的一个子区域，用于显示不同的命令行。</li></ul><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul><li><p><strong>会话</strong> - 每个会话都是一个独立的工作区，其中包含一个或多个窗口</p><ul><li><code>tmux</code> 开始一个新的会话</li><li><code>tmux new -s NAME</code> 以指定名称开始一个新的会话</li><li><code>tmux ls</code> 列出当前所有会话</li><li>在 <code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离</li><li><code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code> 来指定具体的会话</li></ul></li><li><p><strong>窗口</strong> - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分</p><ul><li><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用 <code>&lt;C-d&gt;</code> 关闭</li><li><code>&lt;C-b&gt; N</code> 跳转到第 <em>N</em> 个窗口，注意每个窗口都是有编号的</li><li><code>&lt;C-b&gt; p</code> 切换到前一个窗口</li><li><code>&lt;C-b&gt; n</code> 切换到下一个窗口</li><li><code>&lt;C-b&gt; ,</code> 重命名当前窗口</li><li><code>&lt;C-b&gt; w</code> 列出当前所有窗口</li></ul></li><li><p><strong>面板</strong> - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell</p><ul><li><code>&lt;C-b&gt; &quot;</code> 水平分割</li><li><code>&lt;C-b&gt; %</code> 垂直分割</li><li><code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键</li><li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放</li><li><code>&lt;C-b&gt; [</code> 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li><li><code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li></ul></li></ul><h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>用于创建命令别名。<br>例如：<code>alias ll=&#39;ls -la&#39;</code><strong>注意等号左右都没有空格。</strong><br><code>unalias 别名</code>删除别名 <code>alias</code>查看所有别名<br>为了使自定义的别名在每次打开终端时都生效，可以将它们写入 shell 的配置文件中。</p><ul><li><strong>Bash:</strong> <code>~/.bashrc</code></li><li><strong>Zsh:</strong> <code>~/.zshrc</code></li></ul><h2 id="配置文件dotfiles"><a href="#配置文件dotfiles" class="headerlink" title="配置文件dotfiles"></a>配置文件dotfiles</h2><p>这些文件通常<strong>隐藏</strong>在你的用户目录下，用来存储各种应用程序和操作系统的个性化设置。<br>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 <code>export PATH=&quot;$PATH:/path/to/program/bin&quot;</code> 的命令，这样才能确保这些程序能够被 shell 找到。</p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h3><p><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></p><ul><li><code>-t rsa</code>：指定使用 RSA 算法。</li><li><code>-b 4096</code>：密钥长度为 4096 位，保证更高的安全性。</li><li><code>-C &quot;your_email@example.com&quot;</code>：注释，用于标识这个密钥，一般填写你的邮箱地址。<br><code>Enter file in which to save the key (/home/your_user/.ssh/id_rsa):</code><br>这里保持默认按enter。<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Enter</span> <span class="hljs-variable">passphrase</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">empty</span> <span class="hljs-variable">for</span> <span class="hljs-variable">no</span> <span class="hljs-variable">passphrase</span><span class="hljs-punctuation">)</span><span class="hljs-operator">:</span> <br><span class="hljs-built_in">Enter</span> <span class="hljs-variable">same</span> <span class="hljs-variable">passphrase</span> <span class="hljs-variable">again</span><span class="hljs-operator">:</span><br></code></pre></td></tr></table></figure><code>ls -al ~/.ssh</code>查看密钥文件<br><code>cat ~/.ssh/id_rsa.pub</code><br>将该公钥粘贴到你想要连接的远程服务器或服务上。通常是粘贴到 <code>~/.ssh/authorized_keys</code> 文件或在服务中配置 SSH 公钥。</li></ul><h3 id="ssh-copy-id"><a href="#ssh-copy-id" class="headerlink" title="ssh-copy-id"></a>ssh-copy-id</h3><p>用于将本地主机的公钥复制到远程主机的 <code>authorized_keys</code> 文件中的命令行工具。允许使用 SSH 密钥进行无密码登录。<br><code>ssh-copy-id [options] user@host</code><br><strong>选项：</strong></p><ul><li><code>-i identity_file</code>: 指定要使用的私钥文件（默认为 <code>~/.ssh/id_rsa</code>）。</li><li><code>-f authorized_keys_file</code>: 指定远程主机的 <code>authorized_keys</code> 文件（默认为 <code>~/.ssh/authorized_keys</code>）。</li><li><code>-K</code>: 将公钥添加到远程主机的 <code>known_hosts</code> 文件中。</li><li><code>-R</code>: 从远程主机的 <code>authorized_keys</code> 文件中删除公钥。</li></ul><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><ul><li><strong>-r</strong>：递归复制整个目录。</li><li><strong>-p</strong>：保留文件属性（权限、时间戳等）。</li><li><strong>-v</strong>：显示详细的传输过程。</li><li><strong>-q</strong>：静默模式，不显示输出。</li><li><strong>-i identity_file</strong>：指定使用的私钥文件。</li></ul><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p><code>rsync [options] source destination</code><br><strong>常用选项</strong></p><ul><li><strong>-a</strong>：归档模式，保留文件属性（权限、时间戳等）。</li><li><strong>-v</strong>：详细模式，显示传输过程。</li><li><strong>-z</strong>：压缩传输数据，提高效率。</li><li><strong>-r</strong>：递归同步整个目录。</li><li><strong>-u</strong>：更新模式，仅传输更新的文件。</li><li><strong>-t</strong>：保留文件修改时间。</li><li><strong>-p</strong>：保留文件权限。</li><li><strong>-P</strong>：保留文件所有者和组。</li><li><strong>–progress</strong>：显示传输进度。</li><li><strong>–delete</strong>：删除目标中不存在的源文件。</li></ul><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><p>1、答：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">sleep</span> <span class="hljs-number">10000</span> &amp;<br>pgrep <span class="hljs-literal">-af</span> <span class="hljs-built_in">sleep</span><br>pkill <span class="hljs-operator">-f</span> <span class="hljs-built_in">sleep</span><br></code></pre></td></tr></table></figure><p>2、<code>kill</code> 命令成功退出时其状态码为 0 ，其他状态则是非 0。<code>kill -0</code> 则不会发送信号，但是会在进程不存在时返回一个不为 0 的状态码。<br>答：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>  <br><br><span class="hljs-comment"># 定义 pidwait 函数</span><br><br><span class="hljs-function"><span class="hljs-title">pidwait</span></span>() &#123;<br><br><span class="hljs-built_in">local</span> pid=<span class="hljs-variable">$1</span> <span class="hljs-comment"># 获取进程的 PID</span><br><span class="hljs-comment"># 将标准暑促和标准错误输出丢弃，不输出在终端</span><br><br><span class="hljs-keyword">while</span> ps -p <span class="hljs-string">&quot;<span class="hljs-variable">$pid</span>&quot;</span> &gt; /dev/null 2&gt;&amp;1; <span class="hljs-keyword">do</span> <span class="hljs-comment"># 使用 ps 检查进程是否存在，只要 `ps` 命令的返回值为 0（表示进程存在），就一直循环。</span><br><br><span class="hljs-built_in">sleep</span> 1 <span class="hljs-comment"># 每秒轮询一次，减少 CPU 占用</span><br><br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Process <span class="hljs-variable">$pid</span> has finished.&quot;</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment"># 将函数导出到当前 shell 会话中</span><br><br><span class="hljs-built_in">export</span> -f pidwait<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;pidwait function loaded into the current session.&quot;</span><br></code></pre></td></tr></table></figure><p>然后在当前目录下运行该脚本，并确保它在当前shell会话中定义了pidwait函数<code>source filename.sh</code>。然后再执行pidwait &lt;pid&gt;即可。</p>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2024/10/22/Git/"/>
    <url>/2024/10/22/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>本文基于<a href="https://liaoxuefeng.com/books/git/what-is-git/svn-vs-git/index.html">https://liaoxuefeng.com/books/git/what-is-git/svn-vs-git/index.html</a><br>Git Cheat Sheet<a href="https://liaoxuefeng.com/books/git/conclusion/git-cheat-sheet.pdf">https://liaoxuefeng.com/books/git/conclusion/git-cheat-sheet.pdf</a></p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p><code>git init</code>把这个目录变成Git可以管理的仓库<br><code>git add file</code>添加文件到库<br><code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容。</p><h2 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h2><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态<br><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式<br>提交新文件或者修改仍然使用<code>git add file</code></p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p><code>git log</code>命令显示从最近到最远的提交日志，加上<code>--pretty=oneline</code>参数可以使输出更简化。<br>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写成<code>HEAD~100</code>。<br><code>git reset</code>：<code>--hard</code>会回退到上个版本的已提交状态，而<code>--soft</code>会回退到上个版本的未提交状态，<code>--mixed</code>会回退到上个版本已添加但未提交的状态。<br>例如：<code>git reset --hard HEAD^</code><br>如果要退回现在的版本，只要上面的命令行窗口还没有被关掉，找到HEAD版本的找到那个<code>append GPL</code>的<code>commit id</code>是什么，使用<code>git reset --hard &lt;commit id&gt;</code>即可，版本号没必要写全，前几位就可以了。<br>如果已经关闭了命令行窗口，则要通过<code>git reflog</code>（用来记录你的每一次命令）来查看当时的commit id。</p><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p><code>git checkout -- file</code>可以丢弃工作区的修改（<code>git restore file</code>也可以）<br>这里有两种情况：<br>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br><code>it reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><code>git rm</code>删掉，并且<code>git commit</code>：从版本库中删除该文件<br>先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和<code>git add &lt;file&gt;</code>效果是一样的。<br>把误删的文件恢复到最新版本：<code>git checkout -- file</code></p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>远程库的名字就是<code>origin</code><br>以后只要本地作了提交，就可以通过命令<code>git push origin main</code>把本地main分支的最新修改推送至github。</p><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p><code>git clone git@github.com:BlakeHansen130/repositoy-name.git</code><br>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><h4 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h4><p><code>git checkout -b dev</code>：<code>-b</code>表示创建并切换，相当于以下两条命令：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q">git branch <span class="hljs-built_in">dev</span><br>git checkout <span class="hljs-built_in">dev</span> # 切换到<span class="hljs-built_in">dev</span>分支<br></code></pre></td></tr></table></figure><p>用<code>git branch</code>命令查看当前分支：当前分支前面会标一个<code>*</code>号。<br>把dev分支的工作成果合并到main上：<code>git merge dev</code>用于合并指定分支到当前分支。<br><code>git branch -d dev</code>删除dev分支。</p><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p><code>git switch -c dev</code>创建并切换到新的分支<br><code>git switch main</code>切换到已有的分支</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容<br><code>git log --graph --pretty=oneline --abbrev-commit</code>可以看到分支的合并情况。<br>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；<br>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。<br>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p><code>git stash</code>：把当前工作现场“储藏”起来，等以后恢复现场后继续工作。<br><code>git stash list</code>查看工作现场：<br>一是用<code>git stash apply</code>恢复，但是恢复后，<code>stash</code>内容并不删除，你需要用<code>git stash drop</code>来删除；<br>另一种方式是用<code>git stash pop</code>，恢复的同时把<code>stash</code>内容也删了。<br>你可以多次<code>stash</code>，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的<code>stash</code>，用命令：<code>git stash apply stash@&#123;0&#125;</code></p><h4 id="如何在另一分支上修改同样的bug？"><a href="#如何在另一分支上修改同样的bug？" class="headerlink" title="如何在另一分支上修改同样的bug？"></a>如何在另一分支上修改同样的bug？</h4><p><code>git cherry-pick &lt;bug-fixed commit id&gt;</code>能复制一个特定的commit到当前分支</p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。<br><code>git branch -D &lt;name&gt;</code>强行丢弃没有合并过的分支。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p><code>git remote</code>查看远程库信息<br><code>git remote -v</code>显示更详细的信息，上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。<br>从远程库clone时，默认情况下，只能看到本地的<code>master</code>分支。<br>要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，用这个命令创建本地<code>dev</code>分支：<code>git checkout -b dev origin/dev</code><br>有冲突时，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送。<br>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，即没有关联，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。<br><code>git rebase</code></li></ul><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>先切换到需要打标签的分支上，再<code>git tag &lt;name&gt;</code>即可对最新的commit打标签。如果要对历史commit打标签，则<code>git tag &lt;name&gt; &lt;commit id&gt;</code>。<br><code>git tag</code>可以查看所有标签，标签不是按时间顺序列出，而是按字母排序的。<br><code>git show &lt;name&gt;</code>可以查看标签信息。<br>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：<br>例如：<code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</code><br><strong>标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</strong></p><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p><code>git tag -d &lt;name&gt;</code>删除标签。创建的标签都只存储在本地，不会自动推送到远程。<br><code>git push origin &lt;name&gt;</code>推送标签。一次性推送全部：<code>git push origin --tags</code><br>如果标签已经推送到远程，先从本地删除<code>git tag -d &lt;name&gt;</code>，再从远程删除<code>git push origin :refs/tags/&lt;name&gt;</code>。</p><h2 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h2><p>点“Fork”就在自己的账号下克隆了一个仓库，然后，从自己的账号下clone,这样才能推送修改。如果你希望官方库能接受你的修改，你就可以在GitHub上发起一个pull request。</p><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>在Git工作区的<strong>根目录</strong>下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。<br>检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。<br>如果想强制添加.ignore文件中的文件到Git，那么<code>git add -f file</code>；也可以用<code>git check-ignore</code>来检查哪行规则忽略了该文件。<br>把指定文件排除在<code>.gitignore</code>规则外的写法就是<code>!</code>+文件名，所以，只需把例外文件添加进去即可。<br>在线生成<code>.gitignore</code>文件并直接下载：<a href="https://michaelliao.github.io/gitignore-online-generator/">https://michaelliao.github.io/gitignore-online-generator/</a><br>一个Git仓库也可以有多个<code>.gitignore</code>文件，<code>.gitignore</code>文件放在哪个目录下，就对哪个目录（包括子目录）起作用。</p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。每个仓库的Git配置文件都放在<code>.git/config</code>文件中，当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Data Wrangling</title>
    <link href="/2024/10/22/Data%20Wrangling/"/>
    <url>/2024/10/22/Data%20Wrangling/</url>
    
    <content type="html"><![CDATA[<h1 id="Data-Wrangling"><a href="#Data-Wrangling" class="headerlink" title="Data Wrangling"></a>Data Wrangling</h1><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p><strong>sed</strong> 是 <strong>stream editor</strong> 的缩写，中文译为 <strong>流编辑器</strong>。它是一种强大的文本处理工具，可以在命令行下编辑文本文件或管道中的数据。</p><h3 id="sed的常用命令格式"><a href="#sed的常用命令格式" class="headerlink" title="sed的常用命令格式"></a>sed的常用命令格式</h3><p>Bash</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sed</span> [选项] <span class="hljs-string">&#x27;命令&#x27;</span> 输入文本<br></code></pre></td></tr></table></figure><ul><li><p><strong>选项</strong>：</p><ul><li><code>-n</code>: 静默模式，只有经过sed命令处理的行才会被输出。</li><li><code>-e</code>: 直接在命令行上进行sed的编辑。</li><li><code>-f</code>: 从指定文件中读取sed命令。</li><li><code>-r</code>: 支持扩展正则表达式。</li></ul></li><li><p><strong>命令</strong>：</p><ul><li><code>s/pattern/replacement/</code>: 搜索并替换，其中<code>pattern</code>是正则表达式，<code>replacement</code>是替换字符串。</li><li><code>d</code>: 删除行。</li><li><code>p</code>: 打印行。</li><li><code>a\text</code>: 在行后追加文本。</li><li><code>i\text</code>: 在行前插入文本。</li><li><code>c\text</code>: 用新文本替换行。</li><li><code>n</code>: 读取下一行，并输出pattern space中的行。</li><li><code>g：</code> global 的缩写，表示用于在<strong>同一行</strong>中对所有符合条件的子字符串进行全局替换。</li><li><code>y</code>：替换命令，两个字符集中的字符必须一一对应。</li></ul></li></ul><p>例如：<code>sed &#39;s/old/new/g&#39; file.txt</code>表示在每行行首添加“prefix_”。<br><img src="/img/learn/20241021142246.png"><br>第一段意思是去掉含有a或b的内容；第三段是去掉含有“ab”的内容；第二段失败是因为没有对小括号进行转义，-E是表明采用扩展正则表达式（可以理解为整句转义），也可以采用\(\)的方法。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>假设有一个字符串 “Hello, World!”，那么：</p><ul><li><p><code>.*</code> 可以匹配整个字符串 “Hello, World!”</p></li><li><p><code>.*World</code> 可以匹配 “Hello, World”</p></li><li><p><code>^.*World$</code> 可以精确匹配整个字符串 “Hello, World!”</p></li><li><p><strong>贪婪匹配：</strong> 默认情况下，<code>. *</code> 是贪婪匹配的，也就是会尽可能匹配更多的字符。</p></li><li><p><strong>非贪婪匹配：</strong> 如果想让它匹配尽可能少的字符，可以在 <code>*</code> 后加 <code>?</code>，变成 <code>.*?</code>。</p></li><li><p><strong>匹配顺序：</strong> 正则表达式引擎是从左向右进行匹配的。一旦找到一个匹配 <code>.*World</code> 的子串，它就会认为匹配成功，而不会继续向后查找。</p></li></ul><h3 id="正则表达式的常见模式："><a href="#正则表达式的常见模式：" class="headerlink" title="正则表达式的常见模式："></a>正则表达式的常见模式：</h3><ul><li><code>.</code> 除换行符之外的 “任意单个字符”，即通配符。而.用专门的\.来表示。问号<code>?</code>同理。</li><li><code>*</code> 匹配前面字符零次或多次</li><li><code>+</code> 匹配前面字符一次或多次</li><li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个。</li><li><code>(RX1|RX2)</code> 任何能够匹配 <code>RX1</code> 或 <code>RX2</code> 的结果</li><li><code>^</code> 行首</li><li><code>$</code> 行尾</li><li>字符\d可用于代替0 到 9 之间的任何数字。</li><li>在正则表达式中使用的最常见空格形式是空格( ␣ <em>)<em>、_制表符</em>( \t )、_换行符</em>( \n ) 和回车符 ( \r )（在 Windows 环境中很有用），这些特殊字符可匹配其各自的空格。此外，空格特殊字符\s可匹配上述<strong>任何</strong>特定空格，</li><li>\b，它匹配单词和非单词字符之间的边界。它在捕获整个单词时非常有用（例如，通过使用模式\w+\b）。<br><img src="/img/learn/20241021224424.png"></li></ul><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>主要用于分页显示文件内容。</p><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><ul><li><strong>基本操作：</strong><ul><li><code>less filename</code>: 打开文件</li><li>空格键：向下翻一页</li><li>b：向上翻一页</li><li>G：跳到文件末尾</li><li>g：跳到文件开头</li><li>&#x2F;pattern：向下搜索 pattern</li><li>?pattern：向上搜索 pattern</li><li>n：重复上一次搜索</li><li>N：反向重复上一次搜索</li></ul></li><li><strong>退出：</strong><ul><li>q：退出 less</li></ul></li></ul><h2 id="代码详解部分"><a href="#代码详解部分" class="headerlink" title="代码详解部分"></a>代码详解部分</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><code>cat ssh.log | sed -E &#39;s/^.*Disconnected from (invalid |authenticating )?user (.*) [0-9.]+ port [0-9]+( \[preauth\])?$/\2/&#39; | head -n100</code><br><strong>正则表达式部分：</strong><br>这是一个匹配 SSH 日志中特定行的正则表达式：</p><ul><li>**<code>^</code>**：表示行的开头。</li><li>**<code>.*</code>**：匹配任意数量的字符。</li><li>**<code>Disconnected from</code>**：匹配具体的 “Disconnected from” 这部分文本。</li><li>**<code>(invalid |authenticating )?</code>**：可选地匹配 “invalid “ 或 “authenticating “（有空格）。<code>?</code> 表示这部分是可选的。这是第一捕获组，如果这部分存在就作为<code>\1</code></li><li>**<code>user (.*)</code>**：匹配 “user “ 后的用户名，并捕获用户名为 **<code>\2</code>**。</li><li>**<code>[0-9.]</code>**：匹配 IP 地址中的数字和点号。</li><li>**<code>port [0-9]</code>**：匹配端口信息。</li><li><code>+</code>：表示前面的表达式 <strong>必须至少出现一次，且可以多次出现</strong>。所以，**<code>[0-9]+</code>** 匹配的是<strong>由一位或多位数字组成的数字序列</strong>，即 1 位、2 位、3 位……或更多位的数字。如果只写成 <strong><code>[0-9]</code></strong> 而没有 <strong><code>+</code><strong>，那么只能匹配</strong>一位数字</strong>的端口号，如 <code>0</code>、<code>1</code>、<code>9</code> 等。</li><li><strong><code>( \[preauth\])?</code><strong>：可选地匹配 “[preauth]”。这是</strong>第三捕获组</strong>，匹配可选的 <code>&quot;[preauth]&quot;</code> 部分。由于这部分不影响用户的提取，因此在替换时没有用到它。</li><li><strong><code>\2</code> 替换：</strong> 提取匹配的用户名，并作为最终输出。<br>**<code>| head -n100</code>**：</li><li>将处理后的结果传递给 <code>head</code>，并只显示前 100 行。</li></ul><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>正则表达式测试工具<a href="https://regex101.com/">https://regex101.com/</a> <strong>强烈推荐！！！</strong><br><code>/.* Disconnected from (invalid |authenticating )?user (.*)[^ ]+ port [0-9]+( \[preauth\])?$/gm</code><br><img src="/img/learn/20241021181659.png"><br>其中[^ ]表示除了空格以外的其他字符。这里不表示行首的原因是：<br>^在方括号（也称字符类）外表示行首，即匹配字符串的开头；在方括号内部表示取反，即匹配不属于该字符类的字符。例如：<code>[^a-z]</code>表示匹配非小写字母的字符。<br>我们可以发现此时用户名是“Disconnected from invalid user wp-user 89.134.42.194 port 38866 [preauth]”，但是因为**<code>.*</code>：** 这里的 <code>.</code> 是贪婪的，它会匹配尽可能多的字符。在匹配 “Disconnected from” 之后，它会一直匹配到字符串的结尾，除非后面的模式无法匹配。因此它把用户名截成了“wp-user 89.134.42.194 port 38866 [preauth]”。我们要修改它只需要添加<code>?</code>。<br><img src="/img/learn/20241021182437.png"><br><strong><code>.*?</code>：</strong> 这里的 <code>?</code> 使 <code>.</code> 变得懒惰（lazy），这意味着它会匹配尽可能少的字符。在匹配 “Disconnected from” 之后，它会尽量匹配最少的字符，直到遇到下一个模式。因此它完整捕获了用户名。<br>但注意sed<strong>不支持该后缀</strong>，因此可以使用perl，例如<code>perl -pe &#39;s/.*?Disconnected from //&#39;</code><br>其中</p><ul><li><strong>-p:</strong> 命令行选项，表示对输入的每一行都执行一次表达式，并将结果输出。</li><li><strong>-e:</strong> 命令行选项，用于在命令行中直接执行Perl表达式。</li></ul><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>用于统计文本文件中的行数、字数和字节数。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">wc</span> [选项] 文件名<br></code></pre></td></tr></table></figure><ul><li><strong>文件名:</strong> 可以是单个文件，也可以是多个文件，甚至可以是通配符。</li><li><strong>选项:</strong><ul><li><strong>-l:</strong> 统计行数</li><li><strong>-w:</strong> 统计字数（以空格分隔）</li><li><strong>-c:</strong> 统计字节数</li><li><strong>-m:</strong> 统计字符数（与 -c 相似，但处理多字节字符的方式不同）</li><li><strong>-L:</strong> 统计最长行的长度</li></ul></li></ul><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>用于对文本文件进行排序的常用工具。</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">sort</span> [选项] 文件名<br></code></pre></td></tr></table></figure><ul><li><strong>文件名:</strong> 可以是单个文件，也可以是多个文件，甚至可以是通配符。</li><li><strong>选项:</strong><ul><li><strong>-r:</strong> 反向排序（降序）</li><li><strong>-n:</strong> 按数值排序</li><li><strong>-f:</strong> 忽略大小写</li><li><strong>-u:</strong> 去除重复行</li><li><strong>-t 分隔符:</strong> 指定字段分隔符，默认为空白字符</li><li><strong>-k POS1[,POS2]:</strong> 其中<strong>POS1:</strong> 排序开始的列或字符位置。<strong>POS2:</strong> 排序结束的列或字符位置（可选）。<strong>列号:</strong> 如果数据以特定的分隔符分隔（如逗号、空格），可以使用列号来指定排序范围。例如，<code>-k 2</code> 表示按第二列排序。<strong>字符位置:</strong> 如果数据没有明确的分隔符，可以使用字符位置来指定排序范围。例如，<code>-k 5,10</code> 表示从第5个字符到第10个字符之间的文本作为排序键。例如：<code>-k 3,5: 命令会提取每行数据的第3个到第5个字符作为排序的“键”。</code></li><li><strong>-o 输出文件:</strong> 将排序结果输出到指定文件</li></ul></li></ul><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>用于去除文本文件中重复行的工具。### 基本用法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">uni<span class="hljs-string">q [选项]</span> 文件名<br></code></pre></td></tr></table></figure><ul><li><strong>文件名:</strong> 可以是单个文件，也可以是多个文件，甚至可以是通配符。</li><li><strong>选项:</strong><ul><li><strong>-c:</strong> 在每行前面显示重复的行数</li><li><strong>-d:</strong> 只显示重复的行</li><li><strong>-u:</strong> 只显示唯一的行</li><li><strong>-i:</strong> 忽略大小写</li><li><strong>-f N:</strong> 忽略前 N 个字段</li><li><strong>-s N:</strong> 忽略前 N 个字符</li><li>-<strong>l</strong>:显示总行数。</li></ul></li></ul><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>可以读取文本文件，逐行处理，并对每一行进行各种操作，包括提取、修改、过滤、统计等。适合对列操作。<code>awk</code> 的域分隔符（默认是空格，可以通过 <code>-F</code> 来修改）。</p><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">awk [选项] <span class="hljs-string">&#x27;pattern &#123; action &#125;&#x27;</span> <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><ul><li><strong>选项:</strong><ul><li><strong>-F 分隔符:</strong> 指定字段分隔符，默认为空白字符</li><li><strong>-v 变量&#x3D;值:</strong> 设置变量的值</li></ul></li><li><strong>pattern:</strong> 匹配模式，可以是正则表达式或条件表达式</li><li><strong>action:</strong> 要执行的命令或代码块<br>例如：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 打印文件 data.txt 的第二列</span><br><span class="hljs-attribute">awk</span> <span class="hljs-string">&#x27;&#123; print <span class="hljs-variable">$2</span> &#125;&#x27;</span> data.txt<br><br><span class="hljs-comment"># 打印文件 data.txt 中包含 &quot;apple&quot; 的行</span><br>awk <span class="hljs-string">&#x27;/apple/ &#123; print &#125;&#x27;</span> data.txt<br><br><span class="hljs-comment"># 计算文件 data.txt 的第三列的总和</span><br>awk <span class="hljs-string">&#x27;&#123; sum += <span class="hljs-variable">$3</span> &#125; END &#123; print sum &#125;&#x27;</span> data.txt<br><br><span class="hljs-comment"># 将文件 data.txt 中的第二列和第三列互换</span><br>awk <span class="hljs-string">&#x27;&#123; temp = <span class="hljs-variable">$2</span>; <span class="hljs-variable">$2</span> = <span class="hljs-variable">$3</span>; <span class="hljs-variable">$3</span> = temp; print &#125;&#x27;</span> data.txt &gt; new_data.txt<br></code></pre></td></tr></table></figure>例如：<code>awk &#39;$1 == 1 &amp;&amp; $2 ~ /^c.*e$/ &#123;print $0&#125;&#39;</code>中：<br><code>~</code> 表示正则表达式匹配。<strong>^:</strong> 表示字符串的开头。**.*:** 匹配任意数量的任意字符（包括0个）。**$:** 表示字符串的结尾。<code>$0</code> 表示整个当前行。<br><code>awk &#39;BEGIN &#123; rows = 0 &#125; $1 == 1 &amp;&amp; $2 ~ /^c.*e$/ &#123;rows += 1&#125; END &#123;print rows&#125;&#39;</code><br><code>BEGIN &#123; rows = 0 &#125;</code>: 在处理输入数据之前，初始化一个变量 <code>rows</code>，用于计数。<br><code>&#123;rows += 1&#125;</code>：如果两个条件都满足，则将计数器 <code>rows</code> 加1。</li></ul><h3 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h3><p>将多个文件的内容按照列的形式拼接在一起，形成一个新的文件。</p><h3 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">paste [选项] 文件<span class="hljs-number">1</span> 文件<span class="hljs-number">2</span> ...<br></code></pre></td></tr></table></figure><ul><li><strong>选项:</strong><ul><li><strong>-d &lt;间隔字符&gt;:</strong> 指定列与列之间的分隔符，默认为制表符。</li><li><strong>-s:</strong> 将每个输入文件的行合并为一行输出。</li><li><strong>-d’字符’：</strong> 指定多个分隔符，如-d’, ‘表示用逗号和空格作为分隔符。</li></ul></li></ul><h2 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h2><p>支持任意精度计算的语言。</p><ul><li><strong>-i:</strong> 强制进入交互式模式，方便输入多条命令。</li><li><strong>-l:</strong> 定义使用的标准数学库，提供了更多的数学函数。</li></ul><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>能将一个命令的输出作为另一个命令的参数。</p><h3 id="xargs-的常用选项"><a href="#xargs-的常用选项" class="headerlink" title="xargs 的常用选项"></a>xargs 的常用选项</h3><ul><li><strong>-n num:</strong> 指定每次传递给 command2 的参数个数。</li><li><strong>-p:</strong> 在执行命令前询问用户是否执行。</li><li><strong>-t:</strong> 在执行命令前打印命令行。</li><li><strong>-i{} 或 -I{}:</strong> 将 xargs 的每项名称替换为 {}。</li><li><strong>-d delimiter:</strong> 指定分隔符，默认是空格或换行符。</li><li><strong>-L num:</strong> 从标准输入一次读取 num 行送给 command 命令。<br>例如：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 查找当前目录下所有 .txt 文件并删除</span><br><span class="hljs-built_in">find</span> . -name <span class="hljs-string">&quot;*.txt&quot;</span> | xargs rm<br><br><span class="hljs-comment"># 将 find 命令的输出每一行作为参数传递给 echo 命令</span><br><span class="hljs-built_in">find</span> . -name <span class="hljs-string">&quot;*.txt&quot;</span> | xargs echo<br></code></pre></td></tr></table></figure><code>find . -name &quot;*.txt&quot; | xargs -I &#123;&#125; mv &#123;&#125; &#123;&#125;.bak</code><br><code>-I &#123;&#125;</code>: 告诉 <code>xargs</code> 用 <code>&#123;&#125;</code> 来替换每个输入项。<br><code>mv &#123;&#125; &#123;&#125;.bak</code>中：</li><li><strong>第一个 <code>&#123;&#125;</code>：</strong> 代表要被重命名的原始文件名。它会根据 <code>find</code> 命令的输出，逐一替换为找到的每个 .txt 文件名。</li><li><strong>第二个 <code>&#123;&#125;</code>：</strong> 同样代表原始文件名，但在这里，它会被加上 <code>.bak</code> 后缀，形成新的文件名。</li><li>例如<code>mv file1.txt file1.txt.bak</code>，最后的文件名是原来整体的复制后加.bak。</li></ul><h2 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h2><p><code>ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 - | convert - -colorspace gray - | gzip | ssh tsp &#39;gzip -d | tee copy.png&#39; | feh -</code></p><ul><li><code>-loglevel panic</code>: 只显示致命错误信息</li><li><code>-i /dev/video0</code>: 从摄像头设备读取输入</li><li><code>-frames 1</code>: 只捕获一帧</li><li><code>-f image2</code>: 输出为图片格式</li><li>最后的 <code>-</code> 表示输出到标准输出而不是文件</li><li>gray表示将图像转换为灰度图</li><li>convert中第一个 <code>-</code> 表示从标准输入读取</li><li>convert中第二个 <code>-</code> 表示输出到标准输出</li><li><code>gzip</code>表示压缩数据流，<code>gzip -d</code>: 解压缩数据</li><li>远程主机的名字叫做tsp，在tsp上执行<code>gzip -d | tee copy.png</code></li><li><code>tee copy.png</code>: 保存一份数据到copy.png文件，同时继续输出到标准输出</li><li><code>feh -</code> 表示从标准输入读取图像并显示<br>这个命令链实现了从摄像头捕获一帧图像，转换为灰度图，在保存副本的同时显示图像的功能。<br>ssh甚至可以将<code>cat /dev/video0</code>的视频流实时传输到另一个服务器。</li></ul><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>用于在不同主机之间安全地复制文件和目录。基于SSH协议。</p><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><strong>-r:</strong> 递归复制整个目录。</li><li><strong>-p:</strong> 保留源文件的权限、时间戳等属性。</li><li><strong>-P port:</strong> 指定SSH连接使用的端口号。</li><li><strong>-i identity_file:</strong> 指定私钥文件。</li><li><strong>-c cipher:</strong> 指定加密算法。<br>例如：假设你想将本地目录<code>/home/user/documents</code>中的所有文件复制到远程服务器<code>192.168.1.100</code>的<code>/home/user/backup</code>目录下，并保留所有属性，则：<br><code>scp -r -p /home/user/documents user@192.168.1.100:/home/user/backup/</code></li></ul><h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><h3 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><strong>-d:</strong> 删除字符集1中的所有字符。</li><li><strong>-s:</strong> 压缩重复字符。</li><li><strong>-c:</strong> 补集，即转换或删除字符集1中字符的补集。</li><li><strong>-t:</strong> 截断字符集1，使其与字符集2长度相同。<br>例如：<code>echo &quot;hello world&quot; | tr &#39;a-z&#39; &#39;A-Z&#39;</code>将小写字母转换为大写字母<br><code>echo &quot;  hello  world  &quot; | tr -d &#39; &#39;</code>删除所有空格</li></ul><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><p>2、统计 words 文件 (<code>/usr/share/dict/words</code>) 中包含至少三个 <code>a</code> 且不以 <code>&#39;s</code> 结尾的单词个数。这些单词中，出现频率前三的末尾两个字母是什么？ <code>sed</code> 的 <code>y</code> 命令，或者 <code>tr</code> 程序也许可以帮你解决大小写的问题。共存在多少种词尾两字母组合？还有一个很 有挑战性的问题：哪个组合从未出现过？<br>答：<br>chatgpt:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 将所有单词转换为小写，并过滤至少包含三个 &#x27;a&#x27; 且不以 &#x27;s&#x27; 结尾的单词</span><br><span class="hljs-comment"># 这里第一行的\无实际作用；()除了有捕获的作用还有分组的租用，这里是吧前面三个看为一组。</span><br><span class="hljs-comment"># `&#x27;s$`: 这是我们使用的模式，它会匹配字符串末尾的撇号(&#x27;)后跟着s。这正是我们要找的所有格形式。</span><br><span class="hljs-comment"># `s$`: 这个模式只会匹配末尾的s，会匹配到太多单词，包括：</span><br>    - 普通的复数形式（books）<br>    - 第三人称单数（walks）<br>    - 恰好以s结尾的单词（gas）<br><span class="hljs-comment"># `&#x27;s$&#x27;`: 这种写法在 grep 中是错误的，因为外层的单引号会被 shell 解释为字符串定界符，使得模式变成了 s$，而不是要匹配的实际字符。</span><br><br><span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;[:upper:]&#x27;</span> <span class="hljs-string">&#x27;[:lower:]&#x27;</span> &lt; /usr/share/dict/words | \<br><br>grep -E <span class="hljs-string">&#x27;(.*a.*)&#123;3,&#125;&#x27;</span> | grep -v <span class="hljs-string">&quot;&#x27;s$&quot;</span> | <span class="hljs-built_in">sort</span> &gt; filtered_words.txt<br><br>  <br><br><span class="hljs-comment"># 2. 提取最后两个字母并统计频率，其中substr是截取后缀的意思</span><br><br>awk <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">if (length($0) &gt;= 2) # 确保单词长度大于等于2</span><br><span class="hljs-string"></span><br><span class="hljs-string">print substr($0, length($0)-1)</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;&#x27;</span> filtered_words.txt | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr &gt; suffix_frequency.txt<br><br>  <br><br><span class="hljs-comment"># 3. 显示频率最高的三个词尾组合</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;频率最高的三个词尾组合：&quot;</span><br><br><span class="hljs-built_in">head</span> -n 3 suffix_frequency.txt<br><br>  <br><br><span class="hljs-comment"># 4. 统计不同的词尾组合数量</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;不同的词尾两字母组合数量：&quot;</span><br><br>awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> suffix_frequency.txt | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> | <span class="hljs-built_in">wc</span> -l<br><br>  <br><br><span class="hljs-comment"># 5. 生成所有可能的两字母组合，并按字典顺序排序</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;a..z&#125;; <span class="hljs-keyword">do</span><br><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> &#123;a..z&#125;; <span class="hljs-keyword">do</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;$i<span class="hljs-variable">$j</span>&quot;</span><br><br><span class="hljs-keyword">done</span><br><br><span class="hljs-keyword">done</span> | <span class="hljs-built_in">sort</span> &gt; all_combinations.txt<br><br>  <br><br><span class="hljs-comment"># 6. 提取已出现的组合并排序</span><br><br>awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> suffix_frequency.txt | <span class="hljs-built_in">sort</span> &gt; existing_combinations.txt<br><br>  <br><br><span class="hljs-comment"># 7. 找出未出现的组合</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;未出现的词尾两字母组合：&quot;</span><br><br><span class="hljs-built_in">comm</span> -23 all_combinations.txt existing_combinations.txt<br></code></pre></td></tr></table></figure><h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><p><code>substr(string, start, length)</code> 这个函数在 awk 中有三个参数：</p><ul><li><strong>string:</strong> 要进行截取的字符串。</li><li><strong>start:</strong> 开始截取的位置，从1开始计数。</li><li><strong>length:</strong> 截取的字符数。如果省略，则截取到字符串末尾。</li></ul><h3 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h3><p>用于比较两个已排序的文件，前面的是文件1，后面的是文件2。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>-1: 不显示只在第一个文件中出现过的行。<br><span class="hljs-bullet">- </span>-2: 不显示只在第二个文件中出现过的行。<br><span class="hljs-bullet">- </span>-3: 不显示在两个文件中都出现过的行。<br></code></pre></td></tr></table></figure><p>claude:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>  <br><br><span class="hljs-comment"># 1. 首先统计包含至少三个a且不以&#x27;s结尾的单词</span><br><br><span class="hljs-comment"># 使用tr将所有字母转为小写，然后用grep筛选</span><br><br><span class="hljs-built_in">cat</span> /usr/share/dict/words | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;[:upper:]&#x27;</span> <span class="hljs-string">&#x27;[:lower:]&#x27;</span> | \<br><br>grep -E <span class="hljs-string">&#x27;a.*a.*a&#x27;</span> | \<br><br>grep -v <span class="hljs-string">&quot;&#x27;s$&quot;</span> &gt; filtered_words.txt<br><br>  <br><br><span class="hljs-comment"># 打印符合条件的单词总数</span><br><br>total_words=$(<span class="hljs-built_in">wc</span> -l &lt; filtered_words.txt)<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;符合条件的单词总数: <span class="hljs-variable">$total_words</span>&quot;</span><br><br>  <br><br><span class="hljs-comment"># 2. 提取并统计末尾两个字母</span><br><br><span class="hljs-comment"># 使用awk提取最后两个字母并排序计数</span><br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n末尾两字母出现频率前三：&quot;</span><br><br><span class="hljs-built_in">cat</span> filtered_words.txt | \<br><br>awk <span class="hljs-string">&#x27;&#123;print substr($0, length($0)-1)&#125;&#x27;</span> | \<br><br><span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | <span class="hljs-built_in">head</span> -3<br><br>  <br><br><span class="hljs-comment"># 3. 统计所有出现过的词尾两字母组合数量</span><br><br>total_combinations=$(<span class="hljs-built_in">cat</span> filtered_words.txt | \<br><br>awk <span class="hljs-string">&#x27;&#123;print substr($0, length($0)-1)&#125;&#x27;</span> | \<br><br><span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> | <span class="hljs-built_in">wc</span> -l)<br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n不同的词尾两字母组合总数: <span class="hljs-variable">$total_combinations</span>&quot;</span><br><br>  <br><br><span class="hljs-comment"># 4. 找出未出现过的两字母组合</span><br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n生成所有可能的两字母组合并对比：&quot;</span><br><br><span class="hljs-comment"># 生成所有可能的两字母组合</span><br><br><span class="hljs-keyword">for</span> c1 <span class="hljs-keyword">in</span> &#123;a..z&#125;; <span class="hljs-keyword">do</span><br><br><span class="hljs-keyword">for</span> c2 <span class="hljs-keyword">in</span> &#123;a..z&#125;; <span class="hljs-keyword">do</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;$c1<span class="hljs-variable">$c2</span>&quot;</span><br><br><span class="hljs-keyword">done</span><br><br><span class="hljs-keyword">done</span> &gt; all_combinations.txt<br><br>  <br><br><span class="hljs-comment"># 获取实际出现的组合</span><br><br><span class="hljs-built_in">cat</span> filtered_words.txt | \<br><br>awk <span class="hljs-string">&#x27;&#123;print substr($0, length($0)-1)&#125;&#x27;</span> | \<br><br><span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> &gt; actual_combinations.txt<br><br>  <br><br><span class="hljs-comment"># 找出未出现过的组合</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;部分未出现过的两字母组合示例：&quot;</span><br><br><span class="hljs-built_in">comm</span> -23 all_combinations.txt actual_combinations.txt | <span class="hljs-built_in">head</span> -5<br><br>  <br><br><span class="hljs-comment"># 清理临时文件</span><br><br><span class="hljs-built_in">rm</span> filtered_words.txt all_combinations.txt actual_combinations.txt<br></code></pre></td></tr></table></figure><p>原理类似。<br>3、sed 原地替换的原理：<br>当使用 <code>sed -i &#39;s/REGEX/SUBSTITUTION/ input.txt&#39;</code> 这样的命令时，sed 实际上并不是直接修改原始文件。它的工作流程大致如下：</p><ol><li><strong>读取文件：</strong> sed 将 <code>input.txt</code> 的内容读入内存。</li><li><strong>执行替换：</strong> 根据提供的正则表达式和替换字符串，对内存中的内容进行修改。</li><li><strong>写入临时文件：</strong> 将修改后的内容写入一个临时文件。</li><li><strong>覆盖原文件：</strong> 删除原始的 <code>input.txt</code>，并将临时文件重命名为 <code>input.txt</code>。<br>风险：<br><strong>意外覆盖：</strong> 如果替换命令写错，或者正则表达式匹配不正确，可能会导致大量数据被意外删除或修改，无法恢复。<br>如何安全地进行文本替换：例如：<code>sed &#39;s/REGEX/SUBSTITUTION/g&#39; input.txt &gt; output.txt</code><br>4、找出您最近十次开机的开机时间平均数、中位数和最长时间。在 Linux 上需要用到 <code>journalctl</code> ，而在 macOS 上使用 <code>log show</code>。找到每次起到开始和结束时的时间戳。<br>答：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>  <br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;分析最近10次启动时间...&quot;</span><br><br>  <br><br><span class="hljs-comment"># 使用单独的 --list-boots 来获取可用的启动记录</span><br><br>boot_count=$(journalctl --list-boots | <span class="hljs-built_in">wc</span> -l)<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$boot_count</span> -eq 0 ]; <span class="hljs-keyword">then</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;未找到启动记录&quot;</span><br><br><span class="hljs-built_in">exit</span> 1<br><br><span class="hljs-keyword">fi</span><br><br>  <br><br><span class="hljs-comment"># 获取实际的启动时间数据，每次单独查询</span><br><br><span class="hljs-built_in">times</span>=()<br><span class="hljs-comment"># 初始化数组，用于存储每次启动的时间。</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> 0 -1 -$((boot_count-<span class="hljs-number">1</span>))); <span class="hljs-keyword">do</span><br><br><span class="hljs-comment"># 使用 --boot 参数查询每次启动</span><br><br>boot_time=$(journalctl --boot=<span class="hljs-variable">$i</span> | grep <span class="hljs-string">&quot;Startup finished in&quot;</span> | grep -oP <span class="hljs-string">&#x27;[0-9.]+(?=s)&#x27;</span> | <span class="hljs-built_in">tail</span> -n1)<br><span class="hljs-comment"># seq 0 -1 -$((boot_count-1))：生成一个从 0 开始，步长为 -1，结束值为-boot_count+1的数字序列。这个序列的目的是为了从最新的启动记录开始逆序遍历，以便获取最近的boot_count次启动的时间。</span><br><br><span class="hljs-keyword">if</span> [ ! -z <span class="hljs-string">&quot;<span class="hljs-variable">$boot_time</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-comment"># 判断是否找到启动时间：如果boot_time不为空，则表示成功提取到了启动时间。</span><br><br><span class="hljs-built_in">times</span>+=(<span class="hljs-variable">$boot_time</span>)<br><span class="hljs-comment"># 将启动时间添加到数组： 将提取到的启动时间添加到times数组的末尾。</span><br><span class="hljs-comment"># 如果已经收集了10条记录就退出</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$&#123;#times[@]&#125;</span> -eq 10 ]; <span class="hljs-keyword">then</span><br><br><span class="hljs-built_in">break</span><br><br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># 限制记录数量：如果times数组中的元素个数达到了 10 个，说明已经收集了足够的数据，就跳出循环。</span><br><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">done</span><br><br>  <br><br><span class="hljs-comment"># 检查是否获取到数据</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$&#123;#times[@]&#125;</span> -eq 0 ]; <span class="hljs-keyword">then</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;未能获取到任何启动时间数据&quot;</span><br><br><span class="hljs-built_in">exit</span> 1<br><br><span class="hljs-keyword">fi</span><br><br>  <br><br><span class="hljs-comment"># 计算总和用于平均值</span><br><br><span class="hljs-built_in">sum</span>=0<br><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;times[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span><br><br><span class="hljs-built_in">sum</span>=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$sum</span> + <span class="hljs-variable">$t</span>&quot;</span> | bc -l)<br><br><span class="hljs-keyword">done</span><br><br>  <br><br><span class="hljs-comment"># 计算平均值</span><br><br>avg=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=2; <span class="hljs-variable">$sum</span> / <span class="hljs-variable">$&#123;#times[@]&#125;</span>&quot;</span> | bc -l)<br><br>  <br><br><span class="hljs-comment"># 排序数组用于计算中位数</span><br><br>IFS=$<span class="hljs-string">&#x27;\n&#x27;</span> sorted=($(<span class="hljs-built_in">sort</span> -n &lt;&lt;&lt;<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;times[*]&#125;</span>&quot;</span>))<br><br><span class="hljs-built_in">unset</span> IFS<br><br>  <br><br><span class="hljs-comment"># 计算中位数</span><br><br>mid=$((<span class="hljs-variable">$&#123;#sorted[@]&#125;</span> / <span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">if</span> [ $((<span class="hljs-variable">$&#123;#sorted[@]&#125;</span> % <span class="hljs-number">2</span>)) -eq 0 ]; <span class="hljs-keyword">then</span><br><br>median=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=2; (<span class="hljs-variable">$&#123;sorted[$mid-1]&#125;</span> + <span class="hljs-variable">$&#123;sorted[$mid]&#125;</span>) / 2&quot;</span> | bc -l)<br><br><span class="hljs-keyword">else</span><br><br>median=<span class="hljs-variable">$&#123;sorted[$mid]&#125;</span><br><br><span class="hljs-keyword">fi</span><br><br>  <br><br><span class="hljs-comment"># 找出最长时间</span><br><br>max=<span class="hljs-variable">$&#123;sorted[-1]&#125;</span><br><br>  <br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;分析结果：&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;平均启动时间: <span class="hljs-variable">$&#123;avg&#125;</span>秒&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;中位数启动时间: <span class="hljs-variable">$&#123;median&#125;</span>秒&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;最长启动时间: <span class="hljs-variable">$&#123;max&#125;</span>秒&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;总计分析了 <span class="hljs-variable">$&#123;#times[@]&#125;</span> 次启动记录&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="先行和后行断言"><a href="#先行和后行断言" class="headerlink" title="先行和后行断言"></a>先行和后行断言</h3><ul><li><strong>正向先行断言：</strong> <code>(?=pattern)</code> 表示当前位置的后面必须匹配 pattern。</li><li><strong>负向先行断言：</strong> <code>(?!pattern)</code> 表示当前位置的后面不能匹配 pattern。</li><li><strong>正向后行断言：</strong> <code>(?&lt;=pattern)</code> 表示当前位置的前面必须匹配 pattern。</li><li><strong>负向后行断言：</strong> <code>(?&lt;!pattern)</code> 表示当前位置的前面不能匹配 pattern。<br>例如：假设我们有一个字符串 “This is a test string.”，我们想匹配所有的 “is”，但是要求 “is” 后面必须跟着一个空格。则<code>is(?= )</code></li></ul><h3 id="shell中的数组仍需后续继续学习！！！"><a href="#shell中的数组仍需后续继续学习！！！" class="headerlink" title="shell中的数组仍需后续继续学习！！！"></a>shell中的数组仍需后续继续学习！！！</h3><p>5、1. 查看之前三次重启启动信息中不同的部分(参见 <code>journalctl</code> 的 <code>-b</code> 选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用 <code>sed &#39;0,/STRING/d&#39;</code> 来删除 <code>STRING</code> 匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数(可以使用 <code>uniq</code> )。最后，删除所有出现过 3 次的内容（因为这些内容是三次启动日志中的重复部分）。<br>答：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;=== 错误信息类型统计 ===&quot;</span><br>(journalctl -b 0; journalctl -b -1; journalctl -b -2) | \<br>grep -i <span class="hljs-string">&quot;error\|warning\|failed\|can&#x27;t&quot;</span> | \<br>sed -E <span class="hljs-string">&#x27;s/^[A-Za-z]+ [0-9]+ [0-9:.]+ [^ ]+ [^:]+: //&#x27;</span> | \<br><span class="hljs-comment"># 提取错误信息的主要类型（取每行前40个字符作为关键特征）</span><br>sed -E <span class="hljs-string">&#x27;s/^(.&#123;40&#125;).*/\1.../&#x27;</span> | \<br><span class="hljs-built_in">sort</span> | \<br><span class="hljs-built_in">uniq</span> -c | \<br><span class="hljs-built_in">sort</span> -rn | \<br><span class="hljs-built_in">head</span> -n 5<br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n=== 问题最多的应用 TOP 5 ===&quot;</span><br>(journalctl -b 0; journalctl -b -1; journalctl -b -2) | \<br>grep -i <span class="hljs-string">&quot;error\|warning\|failed\|can&#x27;t&quot;</span> | \<br>sed -E <span class="hljs-string">&#x27;s/^[A-Za-z]+ [0-9]+ [0-9:.]+ [^ ]+ ([^:]+).*/\1/&#x27;</span> | \<br><span class="hljs-built_in">sort</span> | \<br><span class="hljs-built_in">uniq</span> -c | \<br><span class="hljs-built_in">sort</span> -rn | \<br><span class="hljs-built_in">head</span> -n 5<br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n=== 错误等级分布 ===&quot;</span><br>(journalctl -b 0; journalctl -b -1; journalctl -b -2) | \<br>grep -i <span class="hljs-string">&quot;error\|warning\|failed\|can&#x27;t&quot;</span> | \<br>awk <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">    if (tolower($0) ~ /error/) errors++;</span><br><span class="hljs-string">    if (tolower($0) ~ /warning/) warnings++;</span><br><span class="hljs-string">    if (tolower($0) ~ /failed/) failures++;</span><br><span class="hljs-string">    if (tolower($0) ~ /can&#x27;</span>\&#x27;<span class="hljs-string">&#x27;t/) cants++;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">END &#123;</span><br><span class="hljs-string">    print &quot;错误(Error)数量: &quot; errors;</span><br><span class="hljs-string">    print &quot;警告(Warning)数量: &quot; warnings;</span><br><span class="hljs-string">    print &quot;失败(Failed)数量: &quot; failures;</span><br><span class="hljs-string">    print &quot;无法执行(Can&#x27;</span>\&#x27;<span class="hljs-string">&#x27;t)数量: &quot; cants;</span><br><span class="hljs-string">&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>6、</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>  <br><br><span class="hljs-comment"># 下载页面并提取数据</span><br><br><span class="hljs-function"><span class="hljs-title">fetch_and_extract</span></span>() &#123;<br><br><span class="hljs-comment"># 使用curl获取页面内容，使用pup提取表格数据，-s表示静默模式不输出进度信息</span><br><br><span class="hljs-comment"># 安装pup: brew install pup (MacOS) 或 去github下载二进制文件</span><br><br>curl -s <span class="hljs-string">&quot;https://stats.wikimedia.org/EN/TablesWikipediaZH.htm&quot;</span> | \<br><span class="hljs-comment"># 从 HTML 中提取所有&lt;table&gt;标签内的&lt;tr&gt;（表格行）元素，并将其转换为 JSON 格式。</span><br><br>pup <span class="hljs-string">&#x27;table tr json&#123;&#125;&#x27;</span> | \<br><br><span class="hljs-comment"># 使用jq提取文本内容，-r表示原始输出不包含额外的引号</span><br><span class="hljs-comment"># []: 遍历 JSON 数组中的每个元素（即每个表格行）。</span><br><span class="hljs-comment"># [.children[].text]: 提取每个表格行中所有子元素（即表格单元格）的文本内容，并将其作为一个数组。</span><br><span class="hljs-comment"># @tsv: 将数组中的元素以 Tab 分隔符的形式转换为 TSV 格式的字符串。</span><br><br>jq -r <span class="hljs-string">&#x27;.[] | [.children[].text] | @tsv&#x27;</span> | \<br><br><span class="hljs-comment"># 过滤掉空行</span><br><br>grep -v <span class="hljs-string">&#x27;^$&#x27;</span> &gt; wiki_stats.txt<br><br>&#125;<br><br>  <br><br><span class="hljs-comment"># 分析指定列的数据</span><br><br><span class="hljs-function"><span class="hljs-title">analyze_column</span></span>() &#123;<br><br><span class="hljs-built_in">local</span> col=<span class="hljs-variable">$1</span><br><br><span class="hljs-built_in">local</span> title=<span class="hljs-variable">$2</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;=== 分析 <span class="hljs-variable">$title</span> (第<span class="hljs-variable">$&#123;col&#125;</span>列) ===&quot;</span><br><br><span class="hljs-comment"># 提取指定列的数字数据，移除k后缀并转换为数字</span><br><br><span class="hljs-built_in">cat</span> wiki_stats.txt | \<br><span class="hljs-comment"># 将shell变量$col的值赋给awk变量col</span><br><br>awk -v col=<span class="hljs-string">&quot;<span class="hljs-variable">$col</span>&quot;</span> <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">val = $col;</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 如果值以k结尾，将其转换为数字</span><br><span class="hljs-string"></span><br><span class="hljs-string">if (val ~ /k$/) &#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">val = substr(val, 1, length(val)-1) * 1000;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 如果是数字则输出</span><br><span class="hljs-string"></span><br><span class="hljs-string">if (val ~ /^[0-9]+\.?[0-9]*$/) &#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">print val;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;&#x27;</span> | \<br><br><span class="hljs-built_in">sort</span> -n | \<br><br>awk <span class="hljs-string">&#x27;</span><br><span class="hljs-string"></span><br><span class="hljs-string">BEGIN &#123;min=999999999; max=-999999999; sum=0; count=0&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">if ($1 &lt; min) min = $1;</span><br><span class="hljs-string"></span><br><span class="hljs-string">if ($1 &gt; max) max = $1;</span><br><span class="hljs-string"></span><br><span class="hljs-string">sum += $1;</span><br><span class="hljs-string"></span><br><span class="hljs-string">count++;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">END &#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">printf &quot;最小值: %.2f\n&quot;, min;</span><br><span class="hljs-string"></span><br><span class="hljs-string">printf &quot;最大值: %.2f\n&quot;, max;</span><br><span class="hljs-string"></span><br><span class="hljs-string">printf &quot;平均值: %.2f\n&quot;, sum/count;</span><br><span class="hljs-string"></span><br><span class="hljs-string">printf &quot;总和: %.2f\n&quot;, sum;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;&#x27;</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment"># 计算两列之差的总和</span><br><br><span class="hljs-function"><span class="hljs-title">calculate_difference</span></span>() &#123;<br><br><span class="hljs-built_in">local</span> col1=<span class="hljs-variable">$1</span><br><br><span class="hljs-built_in">local</span> col2=<span class="hljs-variable">$2</span><br><br><span class="hljs-built_in">local</span> title1=<span class="hljs-variable">$3</span><br><br><span class="hljs-built_in">local</span> title2=<span class="hljs-variable">$4</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;=== 计算 <span class="hljs-variable">$title1</span> 和 <span class="hljs-variable">$title2</span> 的差值总和 ===&quot;</span><br><br><span class="hljs-built_in">cat</span> wiki_stats.txt | \<br><br>awk -v col1=<span class="hljs-string">&quot;<span class="hljs-variable">$col1</span>&quot;</span> -v col2=<span class="hljs-string">&quot;<span class="hljs-variable">$col2</span>&quot;</span> <span class="hljs-string">&#x27;</span><br><span class="hljs-string"></span><br><span class="hljs-string">function convert(val) &#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">if (val ~ /k$/) &#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">return substr(val, 1, length(val)-1) * 1000;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">return val;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">val1 = convert($col1);</span><br><span class="hljs-string"></span><br><span class="hljs-string">val2 = convert($col2);</span><br><span class="hljs-string"></span><br><span class="hljs-string">if (val1 ~ /^[0-9]+\.?[0-9]*$/ &amp;&amp; val2 ~ /^[0-9]+\.?[0-9]*$/) &#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">diff += (val1 - val2);</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">END &#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">printf &quot;差值总和: %.2f\n&quot;, diff;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;&#x27;</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment"># 主程序</span><br><br><span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;开始获取维基百科统计数据...&quot;</span><br><br>fetch_and_extract<br><br><span class="hljs-comment"># 分析第2列(total)数据</span><br><br>analyze_column 2 <span class="hljs-string">&quot;总用户数&quot;</span><br><br><span class="hljs-comment"># 分析第3列(new)数据</span><br><br>analyze_column 3 <span class="hljs-string">&quot;新用户数&quot;</span><br><br><span class="hljs-comment"># 计算第2列和第3列的差值总和</span><br><br>calculate_difference 2 3 <span class="hljs-string">&quot;总用户数&quot;</span> <span class="hljs-string">&quot;新用户数&quot;</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment"># 执行主程序</span><br><br>main<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vim</title>
    <link href="/2024/10/20/vim/"/>
    <url>/2024/10/20/vim/</url>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>Vim 是一个 <em>多模态</em> 编辑 器：它对于插入文字和操纵文字有不同的模式。Vim 是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim 的接口本身也是一个程序语言：键入操作（以及其助记名） 是命令，这些命令也是可组合的。<br>normal模式下按i进入insert模式；按r进入replace模式；按v进入visual模式；按&lt;S-V&gt;ji进入visual-line模式；按^V进入visual-block模式，，再按esc返回normal。<br>按：进入command-line模式，输入q&lt;enter&gt;退出当前选项卡，qa&lt;enter&gt;退出所有。</p><h2 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h2><p>control+v的三种表示方法：^V Ctrl-V &lt;C-V&gt;</p><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>命令行模式下，:help 后输入想查询的内容可看到功能，注意要问带冒号的命令则也要带冒号，例如:help :w。<code>:w</code>表示保存更改。</p><h3 id="打开文件和缓存"><a href="#打开文件和缓存" class="headerlink" title="打开文件和缓存"></a>打开文件和缓存</h3><ul><li><code>:e &#123;文件名&#125;</code> 打开要编辑的文件</li><li><code>:ls</code> 显示打开的缓存</li></ul><h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><ul><li><strong>分割窗口</strong>：<ul><li><code>:split</code> 或 <code>Ctrl-w s</code>: 水平分割窗口</li><li><code>:vsplit</code> 或 <code>Ctrl-w v</code>: 垂直分割窗口</li></ul></li><li><strong>关闭窗口</strong>：<ul><li><code>:q</code> 或 <code>:close</code>: 关闭当前窗口</li><li><code>:qa</code> 或 <code>:qall</code>: 关闭所有窗口</li></ul></li><li><strong>移动光标到其他窗口</strong>：<ul><li><code>Ctrl-w w</code>: 在窗口之间循环切换</li><li><code>Ctrl-w h/j/k/l</code>: 移动光标到左&#x2F;下&#x2F;上&#x2F;右的窗口</li></ul></li></ul><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><ul><li><strong>查看缓冲区列表</strong>：<ul><li><code>:buffers</code> 或 <code>:ls</code></li></ul></li><li><strong>切换缓冲区</strong>：<ul><li><code>:bn</code> 或 <code>:bp</code>: 切换到下一个&#x2F;上一个缓冲区</li><li><code>:b &#123;number&#125;</code>: 切换到指定编号的缓冲区</li></ul></li><li><strong>删除缓冲区</strong>：<ul><li><code>:bd &#123;number&#125;</code>: 删除指定编号的缓冲区</li></ul></li></ul><h3 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h3><ul><li><strong>创建新选项卡</strong>：<ul><li><code>:tabnew</code> 或 <code>gt</code></li></ul></li><li><strong>关闭选项卡</strong>：<ul><li><code>:tabclose</code> 或 <code>:tabc</code></li></ul></li><li><strong>切换选项卡</strong>：<ul><li><code>gt</code>: 切换到下一个选项卡</li><li><code>gT</code>: 切换到上一个选项卡</li><li><code>:tabn &#123;number&#125;</code>: 切换到指定编号的选项卡</li></ul></li></ul><h2 id="normal模式下的移动"><a href="#normal模式下的移动" class="headerlink" title="normal模式下的移动"></a>normal模式下的移动</h2><ul><li><strong>h:</strong> 向左移动一个字符</li><li><strong>j:</strong> 向下移动一行。在命令前加上数字，表示重复执行该命令的次数。例如，<code>5j</code> 表示向下移动5行。</li><li><strong>k:</strong> 向上移动一行</li><li><strong>l:</strong> 向右移动一个字符</li><li><strong>w:</strong> 移动到下一个单词的开头</li><li><strong>b:</strong> 移动到上一个单词的开头</li><li><strong>e:</strong> 移动到下一个单词的末尾</li><li><strong>^:</strong> 移动到行首</li><li><strong>$:</strong> 移动到行尾</li><li><strong>gg:</strong> 移动到文件开头</li><li><strong>G:</strong> 移动到文件末尾</li><li><strong>Ctrl+u:</strong> 向上滚动半屏</li><li><strong>Ctrl+d:</strong> 向下滚动半屏</li><li><strong>Ctrl+f:</strong> 向下滚动一屏</li><li><strong>Ctrl+b:</strong> 向上滚动一屏</li><li><strong>跳转：</strong> 使用<code>f</code>或<code>t</code>可以跳转到当前行中下一个或上一个出现的指定字符。例如，<code>fx</code> 表示跳转到下一个出现的字母x。</li><li>行数： <code>:&#123;行数&#125;\&lt;CR&gt;</code> 或者 <code>&#123;行数&#125;G</code> ({行数}为行数)</li><li>杂项： <code>%</code> （找到配对，比如括号或者 &#x2F;* *&#x2F; 之类的注释对）</li></ul><h3 id="f命令"><a href="#f命令" class="headerlink" title="f命令"></a>f命令</h3><ul><li><strong>功能：</strong> 将光标移动到当前行中下一个出现的指定字符处。</li><li><strong>用法：</strong> <code>fx</code>，其中x表示你要跳转到的字符。例如，<code>fw</code>表示跳转到下一个单词的开头。</li></ul><h3 id="t命令"><a href="#t命令" class="headerlink" title="t命令"></a>t命令</h3><ul><li><strong>功能：</strong> 将光标移动到当前行中下一个出现的指定字符<strong>之前</strong>。</li><li><strong>用法：</strong> <code>tx</code>，其中x表示你要跳转到的字符。例如，<code>tw</code>表示跳转到下一个单词的开头<strong>之前</strong>。</li></ul><h3 id="扩展用法"><a href="#扩展用法" class="headerlink" title="扩展用法"></a>扩展用法</h3><ul><li><strong>重复跳转：</strong> 使用分号<code>;</code>可以重复上一次的f或t命令。例如，如果你输入<code>fa</code>，然后输入<code>;</code>，光标会继续跳转到下一个出现的”a”。</li><li><strong>反向跳转：</strong> 使用逗号<code>,</code>可以反向重复上一次的f或t命令。例如，如果你输入<code>fa</code>，然后输入<code>,</code>，光标会跳转到上一个出现的”a”。</li><li><strong>结合数字：</strong> 在f或t命令前加上数字，可以指定跳转的次数。例如，<code>2fw</code>表示跳转到下一个单词的开头，然后再跳转到下一个单词的开头。</li><li><strong>大写F和T：</strong> F和T命令与f和t类似，但它们是向左搜索。例如，<code>Fx</code>会向左搜索第一个出现的x。</li><li>屏幕： <code>H</code> （屏幕首行）， <code>M</code> （屏幕中间）， <code>L</code> （屏幕底部）</li></ul><h2 id="insert模式"><a href="#insert模式" class="headerlink" title="insert模式"></a>insert模式</h2><p><strong>Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。</strong></p><h3 id="o命令"><a href="#o命令" class="headerlink" title="o命令"></a>o命令</h3><ul><li><strong>功能：</strong> 在当前行的<strong>下方</strong>插入一个新行，并进入插入模式。</li><li><strong>用法：</strong> 在正常模式下，将光标移动到想要插入新行的位置，然后输入<code>o</code>。</li></ul><h3 id="O命令"><a href="#O命令" class="headerlink" title="O命令"></a>O命令</h3><ul><li><strong>功能：</strong> 在当前行的<strong>上方</strong>插入一个新行，并进入插入模式。</li><li><strong>用法：</strong> 在正常模式下，将光标移动到想要插入新行的位置，然后输入<code>O</code>。</li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><strong>删除字符：</strong><ul><li><code>x</code>：删除光标下的字符</li><li><code>X</code>：删除光标前的字符</li></ul></li><li><strong>删除整行：</strong><ul><li><code>dd</code>：删除当前行</li></ul></li><li><strong>删除到行尾：</strong><ul><li><code>d$</code>：删除从光标处到行尾的所有字符</li></ul></li><li><strong>删除到行首：</strong><ul><li><code>d0</code>：删除从光标处到行首的所有字符</li></ul></li><li><code>s</code> 替换字符（等同于 <code>xi</code>）</li></ul><h3 id="与移动命令结合"><a href="#与移动命令结合" class="headerlink" title="与移动命令结合"></a>与移动命令结合</h3><ul><li><code>dw</code>：删除到下一个单词的开头</li><li><code>de</code>：删除到下一个单词的结尾</li><li><code>db</code>：删除到上一个单词的开头</li><li><code>dd</code>：删除当前行</li><li><code>2dd</code>：删除当前行和下一行</li><li><code>daw</code>：删除光标所在单词</li></ul><h3 id="撤销操作："><a href="#撤销操作：" class="headerlink" title="撤销操作："></a>撤销操作：</h3><ul><li><strong>u：</strong> 撤销上一步操作。连续按多次u可以撤销多个步骤。并且如果从insert模式返回到normal模式以后按u，会撤销在insert模式的所有操作。</li></ul><h3 id="重做操作："><a href="#重做操作：" class="headerlink" title="重做操作："></a>重做操作：</h3><ul><li><strong>Ctrl+r：</strong> 重做上一步撤销的操作。</li></ul><h3 id="其他撤销相关命令："><a href="#其他撤销相关命令：" class="headerlink" title="其他撤销相关命令："></a>其他撤销相关命令：</h3><ul><li><strong>U：</strong> 撤销对当前行的所有修改。</li><li><strong>:undo</strong>：显示撤销列表，并允许你选择要撤销到哪个状态。</li></ul><h3 id="c命令：修改文本"><a href="#c命令：修改文本" class="headerlink" title="c命令：修改文本"></a>c命令：修改文本</h3><ul><li><strong>cw</strong>: 修改光标后的一个单词</li><li><strong>ce</strong>: 修改光标后的一个单词，直到单词末尾</li><li><strong>cb</strong>: 修改光标前的一个单词</li><li><strong>cc</strong>: 修改整行</li><li><strong>c$</strong>: 修改从光标到行尾的所有字符</li><li><strong>c0</strong>: 修改从光标到行首的所有字符<br>c和d唯一的区别就是在删除内容以后将你设置为insert状态</li></ul><h3 id="结合数字"><a href="#结合数字" class="headerlink" title="结合数字"></a>结合数字</h3><ul><li><strong>c2w</strong>: 修改接下来的两个单词</li><li><strong>c3l</strong>: 修改接下来的三个字符</li><li><strong>c.$</strong>: 修改到句号。</li><li><strong>c)</strong>: 修改到下一个”)”。</li><li><strong>c{</strong>: 修改到下一个”{“。</li></ul><h3 id="r命令"><a href="#r命令" class="headerlink" title="r命令"></a>r命令</h3><p><strong>rx</strong>: 将光标下的字符替换为x。例如，<code>ra</code> 将把光标下的字符替换为”a”。</p><ul><li><strong>字符选取：</strong><ul><li><code>v</code>：进入可视模式，然后使用光标键选择字符。</li></ul></li><li><strong>单词选取：</strong><ul><li><code>vw</code>：选中光标所在单词。</li><li><code>ve</code>：选中光标所在单词到单词末尾。</li><li><code>vb</code>：选中光标所在单词到单词开始。</li></ul></li><li><strong>行选取：</strong><ul><li><code>V</code>：进入行可视模式，选中整行。甚至可以按方块形状进行选择。</li><li><code>ggVG</code>：选中整个文件。</li></ul></li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>选中文本后，使用<code>y</code>命令进行复制。例如：</p><ul><li><code>vwyy</code>：选中当前单词并复制。</li><li><code>Vyy</code>：选中当前行并复制。</li></ul><h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p>复制后的文本可以使用<code>p</code>命令进行粘贴。</p><ul><li><code>p</code>：在光标下方粘贴。</li><li><code>P</code>：在光标上方粘贴。</li></ul><h3 id="大小写命令"><a href="#大小写命令" class="headerlink" title="大小写命令"></a>大小写命令</h3><h3 id="单个字符"><a href="#单个字符" class="headerlink" title="#单个字符"></a>#单个字符</h3><ul><li><strong><code>~</code> 命令：</strong> 将光标下的字符大小写反转。</li></ul><h4 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h4><ul><li><strong><code>g~iw</code>：</strong> 将光标下的单词大小写反转。<ul><li>例子：将单词”hello”转换为”HELLO”。</li></ul></li></ul><h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><ul><li><strong><code>guu</code>：</strong> 将当前行所有字母转换为小写。</li><li><strong><code>gUU</code>：</strong> 将当前行所有字母转换为大写。</li><li><strong><code>gu0</code>：</strong> 将光标所在位置到行首的字母转换为小写。</li><li><strong><code>gU0</code>：</strong> 将光标所在位置到行首的字母转换为大写。</li><li><strong><code>gu$</code>：</strong> 将光标所在位置到行尾的字母转换为小写。</li><li><strong><code>gU$</code>：</strong> 将光标所在位置到行尾的字母转换为大写。</li></ul><h4 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h4><ul><li><strong><code>gu</code> 或 <code>gU</code>：</strong> 在可视模式下，选中部分文本后，使用<code>gu</code>将其转换为小写，使用<code>gU</code>将其转换为大写。</li></ul><h2 id="修饰语"><a href="#修饰语" class="headerlink" title="修饰语"></a>修饰语</h2><p>修饰语有 <code>i</code>，表示“内部”或者“在内”，和 <code>a</code>， 表示“周围”。</p><ul><li><code>ci(</code> 改变当前括号内的内容</li><li><code>ci[</code> 改变当前方括号内的内容</li><li><code>da&#39;</code> 删除一个单引号字符串， 包括周围的单引号</li></ul>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shell Tools and Scripting</title>
    <link href="/2024/10/20/Shell%20Tools%20and%20Scripting/"/>
    <url>/2024/10/20/Shell%20Tools%20and%20Scripting/</url>
    
    <content type="html"><![CDATA[<h1 id="Shell-Tools-and-Scripting"><a href="#Shell-Tools-and-Scripting" class="headerlink" title="Shell Tools and Scripting"></a>Shell Tools and Scripting</h1><h2 id="变量-函数"><a href="#变量-函数" class="headerlink" title="变量 函数"></a>变量 函数</h2><p>在shell中要注意空格的使用，尤其是在进行与名字字符串中带有空格的文件有关的操作时。<br><code>&quot;$ variable name&quot;</code>可以使用变量。<br><code>source function</code>可以在shell中执行函数，然后<code>function folder/file</code>就可以检验了。<br><code>$0</code>是脚本名称，<code>$?</code>获取上一个命令的错误代码，<code>$_</code>获取上一个命令参数，例如文件或文件夹等，<code>$#</code>给出的参数数量，<code>$$</code>获取pid(process id)，<code>$@</code>扩展到所有参数。<br>常见的退出状态码示例：</p><ul><li><strong>1：</strong> 一般表示命令执行时出现了错误。</li><li><strong>2：</strong> 可能表示命令使用不正确，例如参数错误。</li><li><strong>127：</strong> 表示命令未找到。</li><li><strong>126：</strong> 表示命令找到，但无法执行（例如没有执行权限）。<br><img src="/img/learn/20241006222138.png"><br><code>!!</code>表示获取上一段命令，例如上一段命令执行结果是没有管理员权限，那么可以<code>sudo !!</code>来解决。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><code>||</code>或，<code>&amp;&amp;</code>与，<code>;</code>分隔多个命令，顺序执行。<br><code>$(command)</code>也可以代表相应的输出内容，<code>cat &lt;(command)</code>也可以实现输出内容。</p><h3 id="dev-null"><a href="#dev-null" class="headerlink" title="&#x2F;dev&#x2F;null"></a>&#x2F;dev&#x2F;null</h3><p>在类Unix系统中是一个特殊的设备文件，常被称为“空设备”或“比特桶”。你可以把它想象成一个无底洞，任何写入到它的数据都会被丢弃，而从它读取数据永远只会得到一个空的回应。<br>&#x2F;dev&#x2F;null 的作用</p><ul><li><strong>丢弃输出：</strong> 当你执行一个命令，但不想看到它的输出结果时，可以将输出重定向到 &#x2F;dev&#x2F;null。这在自动化脚本或批量处理任务中非常常见。</li><li><strong>抑制错误信息：</strong> 某些命令执行时可能会产生错误信息。如果这些错误信息对你来说无关紧要，可以将错误信息重定向到 &#x2F;dev&#x2F;null。</li><li><strong>创建空文件：</strong> 可以通过将特定内容写入 &#x2F;dev&#x2F;null 来创建一个空文件。<br>例如：<code>find / -name &quot;*.tmp&quot; -delete &gt; /dev/null 2&gt;&amp;1</code>这条命令会查找系统中所有以 <code>.tmp</code> 结尾的文件并删除，同时将命令的标准输出和标准错误输出都重定向到 &#x2F;dev&#x2F;null，避免在终端显示任何信息。<code>2&gt;&amp;1</code>这是一个在 Shell 脚本中经常用到的重定向符号，用于 <strong>将标准错误输出重定向到标准输出</strong>。**<code>2&gt;&amp;1</code> 的意思就是：** 把标准错误输出（2）重定向到标准输出（1）。也就是说，原本应该显示在终端上的错误信息，现在也会和正常的输出信息一起显示。</li><li><strong>标准输出（stdout）：</strong> 通常是显示在终端上的输出信息，用数字 1 表示。</li><li><strong>标准错误输出（stderr）：</strong> 通常是显示在终端上的错误信息，用数字 2 表示。</li></ul><h2 id="查看、修改文件"><a href="#查看、修改文件" class="headerlink" title="查看、修改文件"></a>查看、修改文件</h2><p><code>*.sh</code>是大多数sehll文件扩展名。<br><code>ls filename?</code>可以查看相应问号位数名字的文件。<br><code>convert filename.&#123;png.jpg&#125;</code>可以把图片格式从png转化成jpg，也可以加名字序号。<br><code>touch &#123;folder1,folder2&#125;/&#123;file1..filen&#125;</code>可以遍历这两个文件夹中的所有名字中含有某个字符的文件。<br><strong>touch</strong> 命令是一个常用的 Linux&#x2F;Unix 命令，主要用于 <strong>修改文件的时间戳</strong> 或 <strong>创建新文件</strong>。<br><strong>mv -i</strong> 命令在移动或重命名文件时会 <strong>先询问用户</strong>，以避免误操作导致数据丢失。<br>convert可用于转换图片，ffmep可用于处理视频。</p><h2 id="shebang"><a href="#shebang" class="headerlink" title="shebang"></a>shebang</h2><p><strong>&#x2F;usr&#x2F;bin&#x2F;env</strong>： 这部分告诉系统使用 <code>env</code> 命令来查找指定的可执行程序。<code>env</code> 命令会搜索当前用户的环境变量 <code>PATH</code>，找到第一个匹配的程序。<br>例如：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-meta">#!/usr/bin/env python3</span><br>print(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br></code></pre></td></tr></table></figure><p>用系统环境中的 Python3 解释器来执行这个脚本。</p><h2 id="调试-查找"><a href="#调试-查找" class="headerlink" title="调试 查找"></a>调试 查找</h2><p><code>shellcheck *.sh</code>检查警告和语法错误等。<br><strong><code>tldr command</code></strong> 查询命令用法，是一个为命令行工具提供简明易懂的使用说明的工具。它从冗长的 <code>man</code> 手册中提取出最常用的用法和示例，让用户能快速上手各种命令。<br><code>find</code>或<code>fd</code>用于查找文件名字，<code>locate</code>用于查找并列出所有，<code>grep</code>用于查找文件或文件夹中的具体内容，<code>rg</code>是ripgrep的缩写，是比grep更快的文本搜索工具，<code>fzf</code>模糊查找。<br>例如：<code>rg -U --files-without-match &quot;^#\!&quot; -t sh</code>表示<strong>在当前目录及其子目录中，查找所有的 shell 脚本文件（.sh），并找出那些</strong>第一行不是以 <code>#</code> 和 <code>!</code> 开头的的文件。其中<code>^</code>: 表示行首。<code>#</code>: 匹配字符#。<code>\!</code>: 匹配字符 !。<br><code>Ctrl+R</code>可以查找历史中出现要查找的字符的代码，每按一次就出现一条。<br><code>zsh</code>可以提供历史推荐代码。<br><code>tree</code>和<code>broot</code>都是很好的文件搜索和管理工具。</p><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><p>1、要求我们使用 <code>ls</code> 命令，并通过添加不同的参数来实现以下功能：</p><ul><li><strong>显示所有文件（包括隐藏文件）</strong></li><li><strong>以人类可读的格式显示文件大小</strong></li><li><strong>按照文件访问时间排序</strong></li><li><strong>使用彩色输出</strong><br>答：ls -lah –color&#x3D;auto<br>-l 以长格式显示；-a 显示所有文件，包括隐藏文件；-h 以人类可读的格式显示文件大小。</li></ul><p>2、编写两个 bash 函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便 debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code> 命令，（重新）加载函数。<br>答：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># marco.sh</span><br><span class="hljs-comment"># marco 函数：保存当前目录路径</span><br><span class="hljs-function"><span class="hljs-title">marco</span></span>() &#123;<br><span class="hljs-built_in">export</span> SAVED_DIR=<span class="hljs-string">&quot;<span class="hljs-subst">$(pwd)</span>&quot;</span> <span class="hljs-comment"># 使用 export 将变量导出，使得它可以被其他 shell 访问</span><br>&#125;<br><span class="hljs-comment"># polo 函数：跳转回保存的目录</span><br><span class="hljs-function"><span class="hljs-title">polo</span></span>() &#123;<br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$SAVED_DIR</span>&quot;</span> ]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 检查 SAVED_DIR 是否为空，其中-z STRING：如果字符串STRING的长度为零（即为空字符串），则返回真（true），否则返回假（false）。</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error: No directory saved. Please run &#x27;marco&#x27; first.&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$SAVED_DIR</span>&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error: Could not change to directory <span class="hljs-variable">$SAVED_DIR</span>&quot;</span><br><span class="hljs-keyword">fi</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3、假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段 bash 脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。<br>答：修改后的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env bash</span><br><br>  <br><br><span class="hljs-comment"># 初始化计数器</span><br><br>count=0<br><br>log_file=<span class="hljs-string">&quot;command_log.txt&quot;</span> <span class="hljs-comment"># 定义一个变量 log_file ，用来存储日志文件路径</span><br><br>  <br><br><span class="hljs-comment"># 清空或创建日志文件</span><br><br>&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span> <span class="hljs-comment"># 将日志文件清空，如果文件不存在则创建。</span><br><br>  <br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span><br><br><span class="hljs-comment"># 运行给定的命令，同时捕获标准输出和标准错误</span><br><br>n=$((RANDOM % <span class="hljs-number">100</span>)) <span class="hljs-comment"># 生成一个 0 到 99 之间的随机数，并赋值给变量 n。</span><br><br><span class="hljs-keyword">if</span> [[ n -eq 42 ]]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 判断 n 是否等于 42，如果等于，则执行 then 后面的语句。</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Something went wrong&quot;</span> <span class="hljs-comment"># 标准输出。在bash中如果不指定输出重定向，则echo默认标准输出，因此不需要显式指定&gt;&amp;1。</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The error was using magic numbers&quot;</span> &gt;&amp;2 <span class="hljs-comment"># 标准错误输出</span><br><br><span class="hljs-comment"># 记录错误信息到日志文件</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;执行失败，总共执行了 <span class="hljs-variable">$count</span> 次&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;最后一次执行的输出：&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;标准输出：Something went wrong&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;标准错误：The error was using magic numbers&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span><br><br><span class="hljs-comment"># 显示日志文件内容</span><br><br><span class="hljs-built_in">cat</span> <span class="hljs-string">&quot;<span class="hljs-variable">$log_file</span>&quot;</span><br><br><span class="hljs-built_in">exit</span> 1 <span class="hljs-comment"># 退出脚本，并返回一个非零的退出状态，表示程序执行失败。从这里可以跳出while和do的循环。</span><br><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Everything went according to plan&quot;</span><br><br>((count++))<br><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>对于标准输出和标准错误输出，有如下例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"># 将正确的信息输出到 <span class="hljs-built_in">output</span>.txt，错误信息输出到 <span class="hljs-built_in">error</span>.<span class="hljs-built_in">log</span><br>command &gt; <span class="hljs-built_in">output</span>.txt <span class="hljs-number">2</span>&gt; <span class="hljs-built_in">error</span>.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>4、您的任务是编写一个命令，它可以递归地查找文件夹中所有的 HTML 文件，并将它们压缩成 zip 文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行。<br>答：<code>find . -type f -name &quot;*.html&quot; -print0 | xargs -0 zip html_files.zip **使用 </code>-print0<code>和</code>xargs -0&#96;：**</p><ul><li><code>-print0</code> 会让 <code>find</code> 输出的文件名之间用<strong>null 字符</strong> (<code>\0</code>) 进行分隔，而不是空格或换行符。</li><li><code>xargs -0</code> 会识别这些 null 字符，并将整个文件名（包括空格在内）作为一个单独的参数传递。</li></ul><p>5、编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？<br>答：&#96;find &#x2F;path -type f -printf “%T+ %p\n” | sort -r<br>其中</p><ul><li><strong><code>-printf &quot;%T+ %p\n&quot;</code>：</strong> 以 “+%Y-%m-%d %H:%M:%S” 格式输出文件的访问时间和路径。</li><li><strong><code>sort -r</code>：</strong> 按时间戳逆序排序，最近访问的文件排在前面。</li></ul>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Deep Learning by 3Blue1Brown</title>
    <link href="/2024/10/15/3Blue1Brown/"/>
    <url>/2024/10/15/3Blue1Brown/</url>
    
    <content type="html"><![CDATA[<h1 id="Deep-Learning-by-3Blue1Brown"><a href="#Deep-Learning-by-3Blue1Brown" class="headerlink" title="Deep Learning by 3Blue1Brown"></a>Deep Learning by 3Blue1Brown</h1><h3 id="MLP的结构"><a href="#MLP的结构" class="headerlink" title="MLP的结构"></a>MLP的结构</h3><ul><li><strong>输入层：</strong> 接收原始数据，每个神经元对应一个输入特征。</li><li><strong>隐藏层：</strong> 位于输入层和输出层之间，包含多个神经元。隐藏层的神经元通过非线性激活函数对输入数据进行变换，从而提取出数据的特征。</li><li><strong>输出层：</strong> 输出网络的预测结果，神经元的个数取决于任务类型（分类、回归等）。<br><strong>MLP（Multi-Layer Perceptron）</strong>，即<strong>多层感知机</strong>，是深度学习中最基础的神经网络模型之一。它可以看作是感知机的扩展，通过引入多个隐藏层，使得网络能够学习到更加复杂的非线性映射关系。</li></ul><h3 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h3><p>也称为<strong>S型函数</strong>或<strong>逻辑斯蒂函数</strong>，是一种在生物学、信息科学、神经网络等多个领域广泛应用的数学函数。<br>表达式：<code>f(x) = 1 / (1 + e^(-x))</code></p><ul><li><strong>取值范围：</strong> 函数的值域为(0, 1)，这使得它可以将任意实数映射到0到1之间的概率值，常用于表示神经元的激活程度。</li><li><strong>连续性：</strong> Sigmoid函数是连续可导的，这使得它可以用于梯度下降等优化算法。</li><li><strong>非线性：</strong> Sigmoid函数是非线性的，这使得神经网络能够拟合复杂的非线性关系。<br>Sigmoid函数在神经网络中的作用</li><li><strong>作为激活函数：</strong> Sigmoid函数是早期神经网络中常用的激活函数。它可以将线性输入转化为非线性输出，从而使神经网络具有学习复杂模式的能力。</li><li><strong>将输出限制在0-1之间：</strong> 在二分类问题中，Sigmoid函数可以将输出解释为属于正类的概率。<br><strong>机器学习即是要找到正确的权重的偏置，使代价函数最小化。<br>神经网络本身就是一个大型函数。</strong><br><img src="/img/learn/20241014220021.png"></li></ul><h3 id="反向传播算法（Backpropagation，BP）"><a href="#反向传播算法（Backpropagation，BP）" class="headerlink" title="反向传播算法（Backpropagation，BP）"></a>反向传播算法（Backpropagation，BP）</h3><p>工作原理：</p><ol><li><strong>前向传播：</strong> 输入数据从输入层开始，经过隐藏层，最后到达输出层。每一层的神经元计算加权和，并通过激活函数得到输出。</li><li><strong>计算损失：</strong> 将网络的输出与实际的标签进行比较，计算出损失函数的值。常见的损失函数有均方误差、交叉熵损失等。</li><li><strong>反向传播：</strong> 从输出层开始，计算损失函数对输出层每个神经元的偏导数。然后利用链式法则，逐层向前计算损失函数对隐藏层和输入层神经元的偏导数。</li><li><strong>更新参数：</strong> 根据计算得到的梯度，利用梯度下降法更新网络中的权重和偏置。<br>四个计算方程：</li></ol><ul><li><p><strong>误差项 δ 的定义：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">δ<span class="hljs-symbol">^L</span> = ∂C/∂z<span class="hljs-symbol">^L</span><br></code></pre></td></tr></table></figure><p>  其中：</p><ul><li>δ^L：第 L 层第 j 个神经元的误差项。</li><li>C：损失函数。</li><li>z^L：第 L 层第 j 个神经元的输入。</li></ul></li><li><p><strong>误差项 δ 的计算：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">δ<span class="hljs-symbol">^l</span> = (<span class="hljs-keyword">w</span>^(<span class="hljs-keyword">l</span>+<span class="hljs-number">1</span>))<span class="hljs-symbol">^T</span> δ^(<span class="hljs-keyword">l</span>+<span class="hljs-number">1</span>) * σ&#x27;(z<span class="hljs-symbol">^l</span>)<br></code></pre></td></tr></table></figure><p>  其中：</p><ul><li>w^(l+1)：第 l 层到第 l+1 层之间的权重矩阵。</li><li>σ’(z^l)：第 l 层第 j 个神经元的激活函数的导数。</li></ul></li><li><p><strong>偏置的梯度：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">∂C/∂b<span class="hljs-symbol">^l_j</span> = δ<span class="hljs-symbol">^l_j</span><br></code></pre></td></tr></table></figure></li><li><p><strong>权重的梯度：</strong></p>  <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">∂C/∂<span class="hljs-keyword">w</span><span class="hljs-symbol">^l_jk</span> = a^(<span class="hljs-keyword">l</span>-<span class="hljs-number">1</span>)_k δ<span class="hljs-symbol">^l_j</span><br></code></pre></td></tr></table></figure><p>  其中：</p><ul><li>a^(l-1)_k：第 l-1 层第 k 个神经元的输出。</li></ul></li></ul><h3 id="随机梯度下降（Stochastic-Gradient-Descent，SGD）"><a href="#随机梯度下降（Stochastic-Gradient-Descent，SGD）" class="headerlink" title="随机梯度下降（Stochastic Gradient Descent，SGD）"></a>随机梯度下降（Stochastic Gradient Descent，SGD）</h3><p>SGD 的主要特点在于每次迭代只随机选取一个样本（或一小批样本）来计算梯度，并根据这个梯度来更新参数。</p><h3 id="gpt"><a href="#gpt" class="headerlink" title="gpt"></a>gpt</h3><p>GPT，全称Generative Pre-trained Transformer，中文翻译为生成式预训练变换器。<br><strong>Transformer架构:</strong> GPT模型的核心是Transformer架构。Transformer是一种神经网络架构，特别适合处理序列数据，如文本。它利用自注意力机制，让模型能够关注输入序列的不同部分，从而更好地理解文本的上下文。<br>word embedding过后方向可以代表语义。</p><h3 id="softmax函数"><a href="#softmax函数" class="headerlink" title="softmax函数"></a>softmax函数</h3><p>它的作用是将一个任意实数的K维向量“压缩”到另一个K维实向量中，使得每一个元素的范围都在(0,1)之间，并且所有元素的和为1。换句话说，它将输入的数值转化为一个概率分布。其输入称为logits，输出称为probabilities。<br>Softmax函数引入温度参数后的形式：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">y_i = <span class="hljs-built_in">exp</span>(z_i / <span class="hljs-built_in">T</span>) / Σ(<span class="hljs-built_in">exp</span>(z_j / <span class="hljs-built_in">T</span>))<br></code></pre></td></tr></table></figure><ul><li><code>y_i</code>: 输出向量y的第i个元素，表示输入数据属于第i类的概率。</li><li><code>z_i</code>: 输入向量z的第i个元素。</li><li><code>T</code>: 温度参数。<br><strong>高温度 (T较大):</strong> 概率分布会变得更加平滑，各类别之间的概率差异减小，模型会倾向于给所有类别分配较高的概率。这在一些场景下可以增加模型的探索性，例如在生成模型中生成多样化的样本。 <strong>低温度 (T较小):</strong> 概率分布会变得更加尖锐，模型会更加自信地将概率分配给最有可能的类别。这在需要模型做出明确决策的场景下非常有用，例如分类任务。</li></ul><h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><p>它允许模型在处理大量输入数据时，有选择性地关注其中最相关的部分，从而提升模型的性能。<br><strong>数学表达:</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Attention</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Query</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Key</span><span class="hljs-operator">,</span> <span class="hljs-variable">Value</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-variable">softmax</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Query</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">Key</span><span class="hljs-operator">^</span><span class="hljs-variable">T</span> <span class="hljs-operator">/</span> <span class="hljs-variable">sqrt</span><span class="hljs-punctuation">(</span><span class="hljs-type">d_k</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">*</span> <span class="hljs-variable">Value</span><br></code></pre></td></tr></table></figure><ul><li><strong>Query:</strong> 表示当前需要关注的元素。</li><li><strong>Key:</strong> 表示所有输入元素的键。</li><li><strong>Value:</strong> 表示所有输入元素的值。</li><li><strong>softmax:</strong> 将相似度转化为概率分布。</li><li><strong>d_k:</strong> 是Key向量的维度。</li></ul><h3 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h3><p>通常，掩码是一个与输入序列长度相同的向量，每个元素的值为0或1。值为0的位置会被屏蔽，即在计算注意力权重时，这些位置的权重会被设置为一个非常小的负数（例如-inf），从而使得softmax函数将这些位置的概率归为0。<br>掩码的应用场景</p><ul><li><strong>机器翻译:</strong> 防止模型在翻译过程中“偷看”目标序列。</li><li><strong>文本生成:</strong> 确保生成的文本是连贯的，符合语法规则。</li><li><strong>问答系统:</strong> 控制模型只关注与问题相关的部分。</li></ul>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>fyp</title>
    <link href="/2024/10/07/fyp/"/>
    <url>/2024/10/07/fyp/</url>
    
    <content type="html"><![CDATA[<h1 id="fyp"><a href="#fyp" class="headerlink" title="fyp"></a>fyp</h1><p><strong>使用的mcu：</strong><br>esp32<br><strong>历史设备：</strong><br>Kinect for Windows<br><a href="https://learn.microsoft.com/en-us/windows/apps/design/devices/kinect-for-windows">https://learn.microsoft.com/en-us/windows/apps/design/devices/kinect-for-windows</a><br>Nintendo Wii<br><a href="https://www.nintendo.com/en-gb/Wii/Wii-94559.html?srsltid=AfmBOor8Xo1tet1IBXyGMjGHbShVLkBfER8bSEsyGtisKmdRG3AfMNrp">https://www.nintendo.com/en-gb/Wii/Wii-94559.html?srsltid=AfmBOor8Xo1tet1IBXyGMjGHbShVLkBfER8bSEsyGtisKmdRG3AfMNrp</a><br><strong>相关仓库：</strong></p><ul><li><strong>MediaPipe Solutions（重点参考应用案例）:</strong> Google 开发的跨平台框架，包含多种机器学习解决方案，其中手势识别解决方案非常强大，提供了实时、高精度的手势跟踪和分类功能。<ul><li><strong>链接:</strong> <a href="https://github.com/google/mediapipe">https://github.com/google/mediapipe</a></li></ul></li><li><strong>OpenPose:</strong> 一个实时多人二维姿态估计库，可以用于手势识别。它可以准确地检测人体关键点，为手势识别提供基础数据。<ul><li><strong>链接:</strong> <a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose">https://github.com/CMU-Perceptual-Computing-Lab/openpose</a></li></ul></li><li><strong>TensorFlow Examples:</strong> TensorFlow 官方提供的示例代码，包含多个手势识别相关的示例，如使用 TensorFlow 和 Keras 实现手势分类。<ul><li><strong>链接:</strong> <a href="https://github.com/tensorflow/examples">https://github.com/tensorflow/examples</a></li></ul></li><li><strong>RealGes:</strong> 一个基于视觉的实时动态手势识别系统，包含数据采集、模型训练、实时预测等完整流程。<ul><li><strong>链接:</strong> <a href="https://github.com/wzh99/RealGes">https://github.com/wzh99/RealGes</a><br><strong>编程和平台：</strong><br>arduino（功能较弱）<br><strong>Arduino IDE：</strong> Arduino IDE 是一个开源的集成开发环境，通过安装 ESP32 的核心库，可以方便地进行开发。<br>vscode上可以装插件用C++编程。<br><strong>学习：</strong><br>不要看forest和svm，要从cnn、rnn、gan等开始看起。从类似项目中找使用cnn、rnn的方法，从中入手学习。每个人都要交单独的report。中期报告的时候要有设计方案和初步产品。汇报进度时准备PPT。<br><strong>理想流程：</strong><br>先做图像处理，再把数据放进learing model中处理，观察得到的结果。<br><strong>老师推荐的学习链接：</strong><br><a href="https://docs.espressif.com/projects/esp-dl/zh_CN/latest/esp32/index.html">https://docs.espressif.com/projects/esp-dl/zh_CN/latest/esp32/index.html</a><br><a href="https://developer.espressif.com/blog/hand-gesture-recognition-on-esp32-s3-with-esp-deep-learning/">https://developer.espressif.com/blog/hand-gesture-recognition-on-esp32-s3-with-esp-deep-learning/</a><br><a href="https://github.com/margaretmz/awesome-tensorflow-lite">https://github.com/margaretmz/awesome-tensorflow-lite</a><br><a href="https://github.com/espressif/esp-tflite-micro">https://github.com/espressif/esp-tflite-micro</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>fyp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Shell</title>
    <link href="/2024/10/04/The%20Shell/"/>
    <url>/2024/10/04/The%20Shell/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h1><p>刚启动shell terminal的时候出现的是shell prompt<br>shell是一门编程语言，依靠invariable environment</p><h2 id="date-echo-which"><a href="#date-echo-which" class="headerlink" title="date echo which"></a>date echo which</h2><p><code>date</code>显示日期<br><code>echo &quot;string&quot;</code>回复字符串内容<br><code>echo $PATH</code>查看路径<br><code>which echo</code>查看echo程序位置</p><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>linux和macOS中用&#x2F;(forward slash)分隔path，windows中用(back slash)分隔path<br><code>pwd</code>print working directory<br><code>cd</code>change directory<br><code>.</code>current directory <code>..</code>parent directory <code>~</code>表示用户目录，例如在linux中表示&#x2F;home&#x2F;dahao，在windows中表示C:\Users\dahao <code>-</code>表示上一个目录</p><h2 id="ls-man"><a href="#ls-man" class="headerlink" title="ls man"></a>ls man</h2><p><code>ls</code>留空表示显示当前目录，后面也可以加例如..来显示其父目录<br><code>ls --help</code>help <code>ls -l</code>long list help<br><img src="/img/learn/20241004144604.png"><br>每三个字母为一组，第一组为user owner的权限，第二组为group owner的权限，第三组为everyone else，每行的第一个字母表示文件的类型或文件夹</p><ul><li><strong>d:</strong> 代表这是一个目录 (directory)。</li><li><strong>-:</strong> 代表这是一个普通文件 (regular file)。</li><li><strong>l:</strong> 代表这是一个符号链接 (symbolic link)。</li><li><strong>b:</strong> 代表这是一个块设备文件 (block special file)。</li><li><strong>c:</strong> 代表这是一个字符设备文件 (character special file)。</li><li><strong>p:</strong> 代表这是一个管道文件 (FIFO pipe)。</li><li><strong>s:</strong> 代表这是一个套接字文件 (socket)。<br>其中write的权限，对于文件夹来说表示可以在其中rename\create\remove files。例如对文件夹中的某个文件具有write权限，但对文件夹没有write权限，那么只能把文件内容清空而不能把这个文件从文件夹中删掉。<br>execute权限表示想访问一个文件（夹）就需要对它和它父目录有execute权限。<br><code>man ls</code>manual page，可能需要q退出<br><code>Ctrl+L</code>clean terminal<br>在macOS中，<code>xdg-open file</code>用对应软件打开文件</li></ul><h2 id="mv-cp-rm"><a href="#mv-cp-rm" class="headerlink" title="mv cp rm"></a>mv cp rm</h2><p><code>mv</code>move and rename<br><code>cp</code>copy and rename<br><code>rm</code>remove，linux中不能rm文件夹，因为不是递归删除，需要删除加<code>-r</code><br><code>rmdir</code>only if the directory is empty<br><code>mkdir</code>创建新文件夹</p><h2 id="input-output"><a href="#input-output" class="headerlink" title="input output"></a>input output</h2><p><code>&lt;</code>input <code>&gt;</code>output <code>&gt;&gt;</code>append<br><code>cat &lt; file</code>表示把file的内容当做input内容，默认output到terminal<br><code>cat &lt; file &gt; file2</code>表示output到file2中<br><code>tail -n+number</code>例如<code>tail -n2</code>表示print最后2行<br><code>A | B</code>把A代码段的输出作为B代码段的输入，A和B彼此不知<br><strong>重定向的优先级更高</strong></p><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>linux和macOS的root用户id是0，是super user(su)，类似于windows的administrator<br><code>ls /sys</code>kernel parameters<br><code>$</code>表示你不是在以root方式运行 <code>#</code>相反<br><code>sudo su</code>获得root权限 <code>exit</code>退出<br>例如<code>echo 1060 | sudo tee brightness</code>表示先把1060作为输入内容，再获得管理员权限并同时输出到brightness文件和terminal screen</p><h3 id="为什么sudo-echo-500-brightness不行而echo-500-sudo-tee-brightness可以"><a href="#为什么sudo-echo-500-brightness不行而echo-500-sudo-tee-brightness可以" class="headerlink" title="为什么sudo echo 500 &gt; brightness不行而echo 500 | sudo tee brightness可以"></a>为什么<code>sudo echo 500 &gt; brightness</code>不行而<code>echo 500 | sudo tee brightness</code>可以</h3><p>原因：<br><code>sudo echo 500 &gt; brightness</code> 为什么不行？</p><ul><li><strong>重定向优先级高于 sudo：</strong> 在这个命令中，Shell首先会执行重定向操作 <code>&gt; brightness</code>，试图将 <code>echo 500</code> 的输出重定向到 <code>brightness</code> 文件。</li><li><strong>权限不足：</strong> 在执行重定向时，Shell发现你没有写入 <code>brightness</code> 文件的权限，因此报错“不允许”。</li><li><strong>sudo 权限范围：</strong> 即使你使用了 <code>sudo</code>，它也只是提升了 <code>echo</code> 命令的权限，并没有提升 Shell 执行重定向操作的权限。<br><code>echo 500 | sudo tee brightness</code> 为什么可以？</li><li><strong>管道操作：</strong> <code>|</code> 符号表示管道，将 <code>echo 500</code> 的输出作为 <code>sudo tee brightness</code> 的输入。</li><li><strong>sudo tee 权限：</strong> <code>sudo tee brightness</code> 这部分命令由 <code>sudo</code> 提升了权限，因此可以将数据写入 <code>brightness</code> 文件。</li><li><strong>tee 命令的作用：</strong> <code>tee</code> 命令可以同时将标准输入的内容输出到标准输出和指定的文件。<br>总结：</li><li><strong>重定向操作发生在 sudo 之前：</strong> 在 <code>sudo echo 500 &gt; brightness</code> 中，重定向操作先于 <code>sudo</code> 执行，导致权限不足。</li><li><strong>管道操作将输出交给 sudo 处理：</strong> 在 <code>echo 500 | sudo tee brightness</code> 中，重定向操作通过管道交给 <code>sudo tee</code> 处理，从而绕过了权限问题。</li></ul><h2 id="exercise"><a href="#exercise" class="headerlink" title="exercise"></a>exercise</h2><p>使用<code>echo $SHELL</code>命令可以查看您的shell是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则证明可以使用类Unix shell的。<br>如何使用shell，将以下内容一行一行地写入 semester 文件：<br> <code>#!/bin/sh  curl --head --silent https://missing.csail.mit.edu</code><br> 答案：<code>echo &#39;#!/bin/sh&#39; &gt; semester</code><br><code>echo &#39;curl --head --silent https://missing.csail.mit.edu&#39; &gt;&gt; semester</code><br>为什么使用单引号而不是双引号？</p><ul><li>单引号： 单引号内的所有字符都会被原样输出，包括特殊字符（如$、&#96;、\等）。也就是说，单引号内的内容不会被shell解释。</li><li>双引号： 双引号内的部分特殊字符会被shell解释，比如变量会被替换，命令替换也会执行。<br>为什么 # 和 ! 不需要转义？</li><li>#号： 在shell脚本中，#号通常表示注释。当shell遇到#号时，会忽略该行#号后面的所有内容。但是，当#号被包含在单引号或双引号中时，它就失去了注释的作用，而被视为普通字符。</li><li>!号：!号在shell中也有多种用途，但在这里，它只是字符串的一部分，不需要转义。</li><li>如果要在单引号中包含单引号本身，需要使用转义字符&#39;。</li><li>如果需要在单引号中嵌入变量，可以先将变量的值赋值给另一个变量，然后使用双引号包裹这个变量。</li></ul><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>可以通过修改 chmod 命令中的字母来赋予文件不同的权限。</p><h3 id="权限字母详解"><a href="#权限字母详解" class="headerlink" title="权限字母详解"></a>权限字母详解</h3><ul><li>u: 表示文件所有者 (user)</li><li>g: 表示与文件所有者同组的用户 (group)</li><li>o: 表示其他用户 (others)</li><li>a: 表示所有用户 (all users，即 u、g、o 的总和)</li><li>+: 增加权限</li><li>-: 删除权限</li><li>&#x3D;: 设定权限（仅设置指定的权限，其他权限取消）</li><li>r: 读权限</li><li>w: 写权限</li><li>x: 执行权限<br>举例<br>chmod g-w semester: 取消同组用户的写权限<br>chmod o&#x3D;r semester: 仅给其他用户赋予读权限，其他权限取消<br>chmod a+x semester: 给所有用户增加执行权限</li></ul><h3 id="数字表示法"><a href="#数字表示法" class="headerlink" title="数字表示法"></a>数字表示法</h3><p>除了使用字母表示，还可以使用数字表示权限，每个数字代表一组权限：</p><ul><li>rwx: 7</li><li>rw-: 6</li><li>r-x: 5</li><li>r–: 4</li><li>-wx: 3</li><li>-w-: 2</li><li>–x: 1</li><li>—: 0<br>例如：<br>chmod 755 semester: 表示文件所有者有读、写、执行权限，同组用户和其他人有读和执行权限。<br><strong>Shebang 行（#!）的作用：</strong><br>解释器指定: Shebang 行（#!）位于脚本的第一行，其后紧跟着解释器的路径。这行告诉系统，用指定的解释器来执行这个脚本。<br>示例: #!&#x2F;bin&#x2F;sh 表示使用 &#x2F;bin&#x2F;sh 这个 shell 来解释执行脚本。<br>作用: 当系统执行一个脚本时，会首先读取 Shebang 行，然后找到指定的解释器，并把脚本的内容传递给解释器执行。<br><strong>获取修改时间：</strong></li><li>方法一：<code>stat -c %y semester | cut -d &#39; &#39; -f 1 &gt; ./last-modified.txt</code><br>stat -c %y semester：获取semester文件的修改时间，并以年-月-日的格式输出。<br>cut -d ‘ ‘ -f 1：从输出结果中提取第一个字段（即日期），也就是修改时间。<blockquote><p>~&#x2F;last-modified.txt：将提取到的修改时间重定向到当前用户主目录下的last-modified.txt文件中。</p></blockquote></li><li>方法二：<code>ls -l semester | awk &#39;&#123;print $6&quot; &quot;$7&#125;&#39; | cut -d &#39; &#39; -f 1 &gt; ./last-modified.txt</code><br>ls -l semester：以长格式列出semester文件的信息，包括修改时间。<br>awk ‘{print $6” “$7}’：提取输出中的第6和第7个字段，即月日和时间。<br>cut -d ‘ ‘ -f 1：从提取到的结果中提取第一个字段（即日期），也就是修改时间。<blockquote><p>~&#x2F;last-modified.txt：将提取到的修改时间重定向到当前用户主目录下的last-modified.txt文件中。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/02/hello-world/"/>
    <url>/2024/10/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
